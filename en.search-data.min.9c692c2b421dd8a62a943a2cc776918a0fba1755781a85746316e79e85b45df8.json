[{"id":0,"href":"/docs/Git/git-branch/","title":"git branch","section":"Docs","content":" Branch # Git에서 Branch라는 개념은 매우 중요합니다.\n사실상 버전 관리의 꽃이라고 할 수 있습니다.\nhttps://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell\n나뭇가지처럼 여러 갈래로 작업 공간을 나누어 독립적으로 작업할 수 있도록 도와주는 Git의 도구 개발을 하다 보면 코드를 여러 개로 복사해야 하는 일이 자주 생기는데, 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있도록 도움 장점\n독립 공간을 형성하기 때문에 원본(master)에 대해 안전 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적인 개발이 가능 특히나 Git의 브랜치는 매우 가벼우며 순식간에 브랜치를 새로 만들고 브랜치 사이를 이동할 수 있음 브랜치를 꼭 써야할까?\n일단 master 브랜치는 상용을 의미합니다. 그래서 언제든 세상에 공개되어 있습니다. 만약 상용에 에러가 있어서 고쳐야 한다면 어떻게 해야할까요? 고객들이 사용하고 있는데, 함부로 버전을 되돌리거나 삭제할 수 있을까요? 따라서 브랜치를 통해 별도의 작업 공간을 만들고, 그곳에서 되돌리거나 삭제를 합니다. 브랜치는 완전하게 독립이 되어있어서 어떤 작업을 해도 master에는 영향을 끼치지 못하죠. 그리고 이후에 에러를 해결했다면? 그 내용을 master에 반영할 수도 있습니다! 이러한 이유 때문에 Git에서 브랜치는 정말 강력한 기능 중의 하나라고 할 수 있습니다. Branch command # git branch # 브랜치 조회, 생성, 삭제 등 브랜치와 관련된 Git 명령어\n# 브랜치 목록 확인 $ git branch # 원격 저장소의 브랜치 목록 확인 $ git branch -r # 새로운 브랜치 생성 $ git branch \u0026lt;브랜치 이름\u0026gt; # 특정 브랜치 삭제 $ git branch -d \u0026lt;브랜치 이름\u0026gt; # 병합된 브랜치만 삭제 가능 $ git branch -D \u0026lt;브랜치 이름\u0026gt; # (주의) 강제 삭제 (병합되지 않은 브랜치도 삭제 가능) git switch # “Switch branches”\n현재 브랜치에서 다른 브랜치로 HEAD를 이동시키는 명령어 HEAD란 현재 브랜치를 가리키는 포인터를 의미합니다. 2019년 8월 git 2.23 버전에서 출시 https://git-scm.com/docs/git-switch\nhttps ://github.blog/2019-08-16-highlights-from-git-2-23/\n# 다른 브랜치로 이동 $ git switch \u0026lt;다른 브랜치 이름\u0026gt; # 브랜치를 새로 생성과 동시에 이동 $ git switch -c \u0026lt;브랜치 이름\u0026gt; git switch 주의사항\n“git switch 하기 전에, 워킹 디렉토리 파일이 모두 버전 관리가 되고 있나요?\nmaster 브랜치와 feature 브랜치가 있다고 가정해보자 feature 브랜치에서 test.txt를 만들고 git add 하지 않은 상태에서 git switch master를 하면 어떤 일이 발생할까? 바로 feature 브랜치에서 만들었던 test.txt가 master 브랜치에도 똑같이 생성됨 “왜 그럴까?” Git의 브랜치는 독립적인 작업 공간을 가지지만, 어디까지나 Git이 관리하는 파일 트리에 한해서임 git add를 하지 않은, 즉 Staging Area에 한 번도 올라가지 않은 새 파일은 Git의 버전 관리를 받고 있지 않기 때문에 브랜치가 바뀌더라도 계속 유지되는 것 따라서 반드시 git switch를 하기 전에는 모든 워킹 디렉토리의 파일이 버전 관리가 되고 있는지 확인해야 함 Branch scenario # git branch와 git switch를 통해 브랜치를 조회, 생성, 이동하는 실습을 진행\n(1) 사전 세팅 # 홈 디렉토리에 git-branch-practice 폴더를 생성하고 이동 후 vscode를 엽니다.\n$ mkdir git-branch-practice $ cd git-branch-practice $ code . Git 저장소를 생성합니다.\n$ git init Initialized empty Git repository in C:/Users/kyle/git-branch-practice/.git/ test.txt를 생성하고 각각 master-1, master-2, master-3 이라는 내용을 순서대로 입력하여 커밋 3개를 작성합니다.\n$ touch test.txt # test.txt에 master-1 작성 $ git add . $ git commit -m \u0026#34;master-1\u0026#34; # test.txt에 master-2 작성 $ git add . $ git commit -m \u0026#34;master-2\u0026#34; # test.txt에 master-3 작성 $ git add . $ git commit -m \u0026#34;master-3\u0026#34; git log --oneline을 입력했을 때 아래와 같이 나와야 정상입니다. 총 3개의 버전이 master 브랜치에 만들어졌습니다.\n$ git log --oneline 0604dcd (HEAD -\u0026gt; master) master-3 9c22c89 master-2 3d71510 master-1 현재 모습\n(2) 브랜치 생성 및 조회 # 현재 위치(master 브랜치의 최신 커밋)에서 login이라는 이름으로 브랜치를 생성합니다.\n$ git branch login login브랜치가 잘 생성되었는지 확인합니다. * master의 의미는 현재 HEAD가 가리키는 브랜치는 master라는 것입니다.\n$ git branch login * master git log --oneline을 입력했을 때 아래와 같이 나와야 정상입니다. 0604dcd 커밋 기준으로 master와 login브랜치가 위치한 것을 볼 수 있습니다.\n$ git log --oneline 0604dcd (HEAD -\u0026gt; master, login) master-3 9c22c89 master-2 3d71510 master-1 master 브랜치에서 1개의 커밋을 더 작성합니다.\n# test.txt에 master-4 작성 $ git add . $ git commit -m \u0026#34;master-4\u0026#34; 현재 브랜치와 커밋의 상태 확인\n$ git log --oneline 5ca7701 (HEAD -\u0026gt; master) master-4 0604dcd (login) master-3 9c22c89 master-2 3d71510 master-1 현재까지 결과\n(3) 브랜치 이동 # 현재 브랜치와 커밋의 상태는 다음과 같습니다.\n$ git log --oneline 5ca7701 (HEAD -\u0026gt; master) master-4 0604dcd (login) master-3 9c22c89 master-2 3d71510 master-1 이때 login브랜치로 이동하면 어떤 일이 일어날까요?\n$ git switch login master 브랜치의 test.txt에 작성한 master-4가 지워졌습니다!\n# login 브랜치의 test.txt 모습 master-1 master-2 master-3 그리고 git log --oneline을 입력하면 아래와 같이 나타납니다. 이제 HEAD는 login 브랜치를 가리키고, master 브랜치가 보이지 않습니다.\n$ git log --oneline 0604dcd (HEAD -\u0026gt; login) master-3 9c22c89 master-2 3d71510 master-1 master 브랜치는 삭제된 걸까요? 아닙니다! 브랜치를 조회 해보면 다음과 같이 나타납니다. HEAD가 login 브랜치를 가리키면서, log도 login 브랜치 기준으로 보이는 것이었습니다.\n$ git branch * login master git log --oneline --all을 입력하면 모든 브랜치의 로그를 볼 수 있습니다.\n$ git log --oneline --all 5ca7701 (master) master-4 0604dcd (HEAD -\u0026gt; login) master-3 9c22c89 master-2 3d71510 master-1 현재까지 결과\n즉, 브랜치를 이동한다는건 HEAD가 해당 브랜치를 가리킨다는 것을 의미하고,\n브랜치는 최신 커밋을 가리키므로, HEAD가 해당 브랜치의 최신 커밋을 가리키게 됩니다.\n따라서 워킹 디렉토리의 내용도 HEAD가 가리키는 브랜치의 최신 커밋 상태로 변화합니다.\n(4) login 브랜치에서 커밋 생성 # test.txt 파일에 login-1이라고 작성합니다.\n# login 브랜치의 test.txt master-1 master-2 master-3 login-1 추가적으로 test_login.txt도 생성하고 login-1이라고 작성해봅시다.\n$ touch test_login.txt # 이후 test_login.txt에 작성 login-1 커밋을 생성합니다.\n$ git add . $ git commit -m \u0026#34;login-1\u0026#34; git log --oneline --all --graph를 통해 아래와 같은 내용을 확인합니다. master 브랜치와 login 브랜치가 다른 갈래로 갈라진 것을 확인할 수 있습니다.\n$ git log --oneline --graph --all * 3b0a091 (HEAD -\u0026gt; login) login-1 | * 5ca7701 (master) master-4 |/ * 0604dcd master-3 * 9c22c89 master-2 * 3d71510 master-1 현재까지 결과\nBranch Merge # 이제 각 브랜치에서의 작업이 끝나면 어떻게 할까요? 그 작업 내용을 master에 반영해야 하지 않을까요? 지금부터는 Merge라고 하는 병합을 학습하면서 브랜치를 합치는 것을 살펴보자.\ngit merge # 분기된 브랜치들을 하나로 합치는 명령어\ngit merge \u0026lt;합칠 브랜치 이름\u0026gt;의 형태로 사용합니다.\nMerge하기 전에 일단 다른 브랜치를 합치려고 하는, 즉 메인 브랜치로 switch 해야합니다.\n# 1. 현재 branch1과 branch2가 있고, HEAD가 가리키는 곳은 branch1 입니다. $ git branch * branch1 branch2 # 2. branch2를 branch1에 합치려면? $ git merge branch2 # 3. branch1을 branch2에 합치려면? $ git switch branch2 $ git merge branch1 Merge의 세 종류 # 1. Fast-Forward # 브랜치를 병합할 때 마치 빨리감기처럼 브랜치가 가리키는 커밋을 앞으로 이동시키는 것\n현재 master는 C2 커밋을, hotfix는 C4 커밋을 가리키고 있습니다.\nmaster에 hotfix를 병합하면 어떻게 될까요?\n$ git switch master $ git merge hotfix Updating s1d5f1s..1325sd4 Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) hotfix가 가리키는 C4는 C2에 기반한 커밋이므로, master가 C4에 이동하게 됩니다. 이렇게 따로 merge 과정 없이 브랜치의 포인터가 이동하는 것을 Fast-Forward라고 합니다. 병합이 완료된 hotfix는 더 이상 필요 없으므로 삭제합니다.\n$ git branch -d hotfix Deleted branch hotfix (1325sd4). 2. 3-Way Merge (Merge commit) # 브랜치를 병합할 때 각 브랜치의 커밋 두개와 공통 조상 하나를 사용하여 병합하는 것 두 브랜치에서 다른 파일 혹은 같은 파일의 다른 부분을 수정했을 때 가능합니다. 현재 master는 C4 커밋을, iss53은 C5 커밋을 가리키고 있습니다. master와 iss53의 공통 조상은 C2 커밋입니다. 이 상황에서 master에 iss53을 병합하면 어떻게 될까요?\n$ git switch master Switched to branch \u0026#39;master\u0026#39; $ git merge iss53 Merge made by the \u0026#39;ort\u0026#39; strategy. index.html | 1 + 1 file changed, 1 insertion(+) master와 iss53은 갈래가 나누어져 있기 때문에 Fast-Forward로 합쳐질 수 없습니다. 따라서 공통 조상인 C2와 각자가 가리키는 커밋인 C4, C5를 비교하여 3-way merge를 진행합니다.\n이때 생긴 C6는 master와 iss53이 병합되면서 발생한 Merge Commit입니다.\n병합이 완료된 iss53은 더 이상 필요 없으므로 삭제합니다.\n$ git branch -d iss53 Deleted branch iss53 (58sdf23). 3. Merge Conflict # 병합하는 두 브랜치에서 같은 파일의 같은 부분을 수정한 경우, Git이 어느 브랜치의 내용으로 작성해야 하는지 판단하지 못해 발생하는 충돌(Conflict) 현상 결국은 사용자가 직접 내용을 선택해서 Conflict를 해결해야 합니다. 현재 master는 C4 커밋을, iss53은 C5 커밋을 가리키고 있습니다. master와 iss53의 공통 조상은 C2 커밋입니다. (3-way merge에서의 상황과 같습니다)\n3-way merge와는 달리, 만약 master와 iss53이 같은 파일의 같은 부분을 수정하고 병합한다면 어떤 일이 발생할까요?\n$ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. 충돌이 일어난 파일을 확인하기 위해 git status를 입력합니다.\n$ git status On branch master You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: index.html no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) index.html을 열어보면 아래와 같이 충돌 내역이 나옵니다.\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD:index.html \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : email.support@github.com\u0026lt;/div\u0026gt; ======= \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at support@github.com \u0026lt;/div\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; iss53:index.html ======= 를 기준으로 위는 master의 내용, 아래는 iss53의 내용입니다. 이 중 하나를 선택할 수도 있고, 둘 다 선택할 수도 있고, 아예 새롭게 작성할 수도 있습니다.\n\u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; please contact us at email.support@github.com \u0026lt;/div\u0026gt; 이후 git add와 git commit을 통해 병합한 내용을 커밋할 수 있습니다.\n$ git add . $ git commit Vim 편집기가 켜지며 이를 이용해서 커밋 내역을 수정할 수 있습니다. (수정을 마치거나 수정할 것이 더이상 없을 경우 esc 를 누른후:wq 를 입력하여 저장 \u0026amp; 종료)\nMerge branch \u0026#39;iss53\u0026#39; Conflicts: index.html # # It looks like you may be committing a merge. # If this is not correct, please remove the file #\t.git/MERGE_HEAD # and try again. # Please enter the commit message for your changes. Lines starting # with \u0026#39;#\u0026#39; will be ignored, and an empty message aborts the commit. # On branch master # All conflicts fixed but you are still merging. # # Changes to be committed: #\tmodified: index.html # Branch Merge scenario # 사전 세팅\n$ mkdir git_merge $ cd git_merge $ git init $ touch test.txt # test.txt 에 master test 1 을 입력 후 저장 $ git status $ git add . $ git commit -m \u0026#34;master test 1\u0026#34; 3가지 병합 상황 # 1. fast-forward # \u0026ldquo;login 브랜치가 생성된 이후 master 브랜치에 변경 사항이 없는 상황\u0026rdquo;\n즉, master 브랜치에서 login 브랜치를 Merge 할 때 login 브랜치가 master 브랜치 이후의 커밋을 가리키고 있으면 그저 master 브랜치가 login 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐\nlogin branch 생성 및 이동\n$ git switch -c login 특정 작업 완료 후 commit\n$ touch login.txt $ git add . $ git commit -m \u0026#34;login test 1\u0026#34; master 브랜치로 이동\n$ git switch master $ git log --oneline --all --graph * df231d0 (login) login test 1 * 1e62b4c (HEAD -\u0026gt; master) master test 1 master 에 병합 login을 병합\n$ git merge login Updating 43fab3e..2fe539c Fast-forward login.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 login.txt 결과 확인 (fast-foward, 단순히 HEAD를 앞으로 빨리감기)\n$ git log --oneline --all --graph * 2fe539c (HEAD -\u0026gt; master, login) login test 1 * 43fab3e master test 1 login 브랜치를 삭제\n$ git branch -d login Deleted branch login (was df231d0). $ git log --oneline --all --graph * 2fe539c (HEAD -\u0026gt; master) login test 1 * 43fab3e master test 1 2. 3-way Merge (Merge commit) # 현재 브랜치(master)가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니면, git 은 각 브랜치가 가리키는 커밋 2 개와 공통조상 하나를 사용하며 3-way Merge 한다.\n단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge 의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge commit 이라고 부른다.\nsignout 브랜치 생성 및 이동\n$ git switch -c signout 특정 작업 완료 후 commit\n$ touch signout.txt $ git add . $ git commit -m \u0026#34;signout test 1\u0026#34; [signout d9f33e2] signout test 1 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 signout.txt $ git log --oneline --all --graph * d9f33e2 (HEAD -\u0026gt; signout) signout test 1 * 2fe539c (master) login test 1 * 43fab3e master test 1 master 브랜치로 이동\n$ git switch master master 에 추가 작업 후 commit (단, signout 브랜치와 다른 파일을 생성 혹은 수정)\n$ touch master.txt $ git add . $ git commit -m \u0026#34;master test 2\u0026#34; $ git log --oneline --all --graph * 07fae72 (HEAD -\u0026gt; master) master test 2 | * d9f33e2 (signout) signout test 1 |/ * 2fe539c login test 1 * 43fab3e master test 1 master에 signout을 병합 (자동 merge commit 발생)\n$ git merge signout Merge made by the \u0026#39;recursive\u0026#39; strategy. signout.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 signout.txt log 확인\n$ git log --oneline --all --graph * 1170a02 (HEAD -\u0026gt; master) Merge branch \u0026#39;signout\u0026#39; |\\ | * d9f33e2 (signout) signout test 1 * | 07fae72 master test 2 |/ * 2fe539c login test 1 * 43fab3e master test 1 signout 브랜치 삭제\n$ git branch -d signout Deleted branch signout (was d9f33e2). 3. Merge Conflict # Merge 하는 두 브랜치에서 같은 파일의 같은 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 자동으로 Merge 하지 못하고 충돌이 일어남 (반면 동일 파일이더라도 서로 다른 부분을 수정했다면, Conflict 없이 자동으로 Merge Commit 된다.)\nhotfix 브랜치 생성 및 이동\n$ git switch -c hotfix 특정 작업 완료 후 commit\n# test.txt 수정 master test 1 이건 hotfix 에서 작성한 문장이에요!! $ git add . $ git commit -m \u0026#34;hotfix test 1\u0026#34; [hotfix e6cf5ec] hotfix test 1 1 file changed, 2 insertions(+) $ git log --graph --oneline --all * e6cf5ec (HEAD -\u0026gt; hotfix) hotfix test 1 * 1170a02 (master) Merge branch \u0026#39;signout\u0026#39; |\\ | * d9f33e2 signout test 1 * | 07fae72 master test 2 |/ * 2fe539c login test 1 * 43fab3e master test 1 master 브랜치로 이동\n$ git switch master 특정 작업(hotfix 와 동일 파일의 동일 부분 수정) 완료 후 commit\n# text.txt 수정 master test 1 이건 master 에서 작성한 코드에용ㅎㅎ!! $ git add . $ git commit -m \u0026#34;master test 3\u0026#34; $ git log --oneline --all --graph * 1bc2eeb (HEAD -\u0026gt; master) master test 3 | * e6cf5ec (hotfix) hotfix test 1 |/ * 1170a02 Merge branch \u0026#39;signout\u0026#39; |\\ | * d9f33e2 signout test 1 * | 07fae72 master test 2 |/ * 2fe539c login test 1 * 43fab3e master test 1 master에 hotfix를 병합\n$ git merge hotfix 결과 → merge conflict 발생 (같은 파일의 같은 문장을 수정했기 때문)\n충돌 확인 및 해결\nMerge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면 git status 명령을 이용한다. $ git status On branch master You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) (use \u0026#34;git merge --abort\u0026#34; to abort the merge) Unmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: test.txt no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) master test 1 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD 이건 master 에서 작성한코드에용ㅎㅎ!! ======= 이건 hotfix 에서 작성한문장이에요!! \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; hotfix ======= 위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용이고 아래쪽은 hotfix 브랜치의 내용이다. 충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 해야 한다.(\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;, =======, \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 가 포함된 행을 삭제) # test.txt 최종본 master test 1 충돌을 해결해보자!! merge commit 진행\n$ git add . $ git commit VIM 에디터 등장\n자동으로 작성된 커밋 메세지(Merge branch 'hotfix')를 확인하고 esc 를 누른후:wq 를 입력하여 저장 \u0026amp; 종료\n[master eec8da4] Merge branch \u0026#39;hotfix\u0026#39; log 확인\n$ git log --oneline --all --graph * eec8da4 (HEAD -\u0026gt; master) Merge branch \u0026#39;hotfix\u0026#39; |\\ | * e6cf5ec (hotfix) hotfix test 1 * | 1bc2eeb master test 3 |/ * 1170a02 Merge branch \u0026#39;signout\u0026#39; |\\ | * d9f33e2 signout test 1 * | 07fae72 master test 2 |/ * 2fe539c login test 1 * 43fab3e master test 1 hotfix 브랜치를 삭제\n$ git branch -d hotfix Deleted branch hotfix (was e6cf5ec). "},{"id":1,"href":"/docs/Git/git/","title":"Git \u0026 Github","section":"Docs","content":" Why Git \u0026amp; Github? # 1. Git을 이용한 버전 관리 # git : (분산) 버전 관리 프로그램\n버전 : 컴퓨터 소프트웨어의 특정 상태 관리 : 어떤 일의 사무, 시설이나 물건의 유지/개량 프로그램 : 컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 모음 중앙 집중식 버전 관리\n분산 버전 관리\n2. Github 를 이용한 포트폴리오 # TIL Git # git 은 분산버전관리시스템(DVCS) Distributed Control System\n소스코드의 버전을 관리하고 이력도 관리할 수 있다.\n준비하기 # 윈도우에 git 을 설치한다. (git bash 설치)\n초기 설치 완료 후 로컬 컴퓨터에 Author 정보를 설정해야한다.\n$ git config --global user.email 유저이메일 $ git config --global user.name 유저네임 $ git config --global -l // 설정값을 확인하는 명령어 1. 저장소 초기화 # $ git init ~/TIL (master) // master 명 확인으로 git 관리여부 확인 Working Directory Staging Area Local Repository (commit) 실제 작업되는 공간변경점이 나타나면 이곳에 파일이 등록 commit 되기 전 임시로 파일들이 보여지는 곳이곳에서 commit 되어도 되는지 파일을 확인 git 으로 관리되는 파일들의 버전들이 저장되는 곳 2. 상태 확인 # $ git status // WD, SA 상태를 확인하기 위한 명령어 Untracked\ngit 으로 관리되지 않았던 파일이 등록된 경우 WD에서 해당 단어를 확인할 수 있음 Tracked\nNew file : git 으로 관리되지 않았던 파일이 Staging Area 에 등록되었을 때 확인할 수 있음 modified : git 으로 관리되는데 수정된 파일이 Staging Area 에 등록되었을 때 확인할 수 있음 4. gitignore # 프로젝트와 관련 없는 파일을 등록하여 commit 되지 않도록 하는 것\n민감한 개인 파일이나 개인 컴퓨터 설정파일 (OS에서 활용되는 파일) IDE 환경 설정 파일 (.idea/) 가상환경 폴더 및 파일 .gitignore 파일을 생성\n제외하고 싶은 파일을 등록 파일명을 적어주면 끝 gitignore.io 를 이용하면 편하게 .gitignore 파일을 작성할 수 있음\n단, 우리가 생성한 파일은 우리가 직접 등록해야함 (ex. 단순 참고 용도인 파일들) 5. Commit 을 위한 준비 # $ git add 파일명 $ git add . // 현재 폴더 내에 있는 변경/추가된 파일 모두를 등록 Working Directory 에서 Staging Area 로 관리 파일들을 이동시키는 명령어 Staging Area 에서 관리 대상에 대한 판단을 하고 commit 여부를 결정 6. Commit 하기 # $ git commit -m \u0026#34;커밋 메세지를 남기자! 유의미한 내용으로 작성\u0026#34; 버전 이력을 확정짓는 명령어 해당 시점의 파일 변경된 내용을 스냅샷으로 기록해 남긴다. 7. Commit 이력 확인하기 # $ git log $ git log --oneline // 한 줄로 축약해서 보여줌 $ git log -p // 파일의 변경 내용도 같이 보여줌 $ git log -숫자 // 숫자만큼만 보여줌 원격 저장소 (remote repository) # github/gitlab 1. 원격 저장소 등록 # 사용을 하기 위해서는 로컬에 원격 저장소의 url 주소를 등록해야 함\n$ git remote add 저장소별명(origin) 저장소주소 등록된 원격 저장소의 주소를 확인하는 방법\n$ git remote -v 저장소 삭제\n$ git remote rm 저장소별명 2. 원격 저장소에 commit 내용 보내기 # 로컬에 저장된 commit 을 원격 저장소로 전달하여 분산 버전 관리를 완성하는 부분\n$ git push 저장소별명 브랜치명 $ git push -u origin master -u : -set-upstream 의 shortcut 형태이고 저장소 별명과 브랜치 명을 설정 3. 원격 저장소에서 내려받기 # 1. git clone # git init, git remote add 동작이 포함된 내려받기 명령어\n아무것도 없는 상태일 때 사용\ngit clone 리모트레포주소\n2. git pull # remote 서버의 정보를 내려받는 명령어\ngit 이 적용되어 있어야 한다. (.git 폴더가 존재해야함)\nremote 정보가 등록되어 있어야 한다.\ngit pull 리모트별명 브랜치명\n기타) # submodule warning 메세지를 봤다!!! # 어떤 폴더가 submodule 인지 확인한다. 해당 폴더로 찾아가서 .git 폴더를 제거한다. 이미 Staging Area 에 올라간 상태라면 git rm -rf --cached 폴더명으로 해당 폴더를 Staging Area 에서 Working Directory 로 내린다. git status 로 다시 상태를 체크하고 git add 로 staging area 에 다시 올린다. 그리고 다시 git status 로 staging area 에 올라온 상태를 파악하고 git commit 을 한다. CLI 환경에서 (master)가 보이면 git init을 하지 않는게 좋다. "},{"id":2,"href":"/posts/hugo/","title":"Hugo 사용법","section":"Blog","content":" 로컬 서버 실행 # $ hugo server -D "}]