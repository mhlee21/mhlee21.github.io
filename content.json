{"pages":[{"title":"tag","text":"","link":"/tag/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"category","text":"","link":"/category/index.html"}],"posts":[{"title":"CLI (Command Line Interface)","text":"CLI~ : 홈 디렉토리 (현재 로그인 된 사용자의 홈 폴더를 의미) / : 루트 디렉토리 (모든 파일과 폴더를 담고 있는 최상위 폴더) 절대 경로 : 어떤 위치에서도 접근할 수 있는 경로 (모든 경로를 전부 작성) 상대 경로 : 현재 작업하고 있는 디렉토리를 기준으로 계산된 상대적 경로 . : 현재 작업하는 위치 .. : 현재 작업하는 위치의 상위 위치 (상위폴더/부모폴더) 터미널 명령어파일 생성touch : 파일 생성 명령어 1`$ touch 파일명` 폴더 생성mkdir : 폴더 생성 명령어 1$ mkdir 폴더명 파일/폴더의 목록 확인ls : 현재 위치의 폴더/파일의 목록을 보고 싶을 때 사용하는 명령어 -a : 접근 가능한 모든 폴더/파일 확인 -l : 자세한 정보까지 확인하고 싶을 때 파일/폴더 이동하기mv : 폴더/파일을 다른 위치로 이동하거나 이름 변경할 때 사용 12$ mv 이동하려는파일명 이동하는위치$ mv 이름변경하려는파일명 변경하려는이름 현재 위치 이동하기cd : 현재 위치를 이동하기 위한 명령어 1$ cd 이동할위치 폴더/파일 삭제rm : 폴더/파일 삭제하는 명령어 123$ rm 삭제하려는파일명$ rm -r 삭제하려는폴더명$rm -rf 폴더명 : 폴더 무조건 삭제 주의 : 휴지통 개념이 없음. 즉, 되살릴수 없다! 폴더/파일 열기start : 폴더/파일을 여는 명령어 꿀 같은 단축키위,아래 방향키 : 과거에 작성한 명령어를 조회 tab : 자동완성 ctrl + l : 화면 클리어 ctrl + insert : 복사 shift + insert : 붙여넣기","link":"/2022/01/13/CLI/"},{"title":"Django&gt;CRUD with views","text":"HTTP methodGET⭐ 특정 리소스를 가져오도록 요청할 때 사용 반드시 데이터를 가져올 때만 사용해야 함 DB에 변화를 주지 않음 CRUD 에서 R 역할을 담당 POST⭐ 서버로 데이터를 전송할 때 사용 리소스를 생성/변경하기 위해 데이터를 HTTP body 에 담아 전송 서버에 변경사항을 만듦 CRUD 에서 C/U/D 역할을 담당 Cross-site request forgery (CSRF) 사이트간 요청 위조 웹 애플리케이션 취약점 중 하나로 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법 Django는 CSRF에 대항하여 middleware와 template tag 를 제공 CSRF 라고도 함 CSRF 공격 방어⭐ Security Token 사용 방식 (CSRF Token) 사용자의 데이터에 임의의 난수값을 부여해, 매 요청마다 해당 난수 값을 포함시켜 전송 시키도록 함 이후 서버에서 요청을 받을 때마다 전달된 token 값이 유효한지 검증 일반적으로 데이터 변경이 가능한 POST, PATCH, DELETE Method 등에 적용 (GET 제외) Django는 CSRF token 템플릿 태그를 제공 csrf_token template tag {% csrf_token %}⭐ CSRF 보호에 사용 input type 이 hidden 으로 작성되며, value 는 Django에서 생성한 hash 값으로 설정됨 해당 태그 없이 요청을 보낸다면 Django 서버는 403 forbidden 을 응답 ⭐ method가 POST 일때 반드시 설정해야 한다. CSRF Middleware CSRF 공격 관련 보안 설정은 settings.py 에서 MIDDLEWARE에 작성 되어있음 실제로 요청 과정에서 urls.py 이전에 middleware의 설정 사항들을 순차적으로 거치며 응답은 반대로 하단에서 상단으로 미들웨어를 적용시킴 1234💡 Middleware- 공통 서비스 및 기능을 애플리케이션에 제공하는 소프트웨어- 데이터 관리, 애플리케이션 서비스, 메시징, 인증 및 API 관리를 주로 미들웨어를 통해 처리- 개발자들이 애플리케이션을 보다 효율적으로 구축할 수 있도록 지원하며, 애플리케이션, 데이터 및 사용자 사이를 연결하는 요소처럼 작동 Django shortcut functionredirect()⭐ 새 URL 로 요청을 다시 보냄 인자에 따라 HttpResponseRedirect 를 반환 브라우저는 현재 경로에 따라 전제 URL 자체를 재구성(reconstruct) 사용가능한 인자 model view name absolute or relative URL return redirect('articles:detail', article.id)⭐⭐⭐ CRUD 직접 작성해보기 프로젝트 이름 : crud 앱 이름 : articles 앱 등록 (crud/settings.py) 1234567891011# Application definitionINSTALLED_APPS = [ 'articles', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] base 템플릿 작성 및 추가 templates/base.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; {% block content %} {% endblock content %} &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; crud/settings.py 12345TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR / 'templates'], ... READ전체 게시글 조회 articles/urls.py 1234567from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'),] articles/views.py 123456def index(request): articles = Article.objects.all() context = { 'articles': articles, } return render(request, 'articles/index.html', context) templates/articles/index.html 1234567891011121314{% extends 'base.html' %}{% block content %}&lt;h1 class=&quot;fw-bold&quot;&gt;INDEX&lt;/h1&gt;&lt;a href=&quot;{% url 'articles:new' %}&quot; class=&quot;text-decoration-none&quot;&gt;NEW&lt;/a&gt;&lt;br&gt;&lt;br&gt;{% for article in articles %} &lt;h2&gt;제목: {{ article.title }}&lt;/h2&gt; 내용 : {{ article.content }} &lt;br&gt; &lt;a href=&quot;{% url 'articles:detail' article.id %}&quot; class=&quot;text-decoration-none&quot;&gt;DETAIL&lt;/a&gt; &lt;hr&gt;{% endfor %}{% endblock content %} 12345💡 게시글 정렬 순서 변경1. DB로부터 받은 쿼리셋을 이후에 파이썬이 변경articles = Article.objects.all()[::-1]2. 처음부터 내림차순 쿼리셋으로 받음 (DB가 조작)articles = Article.objects.order_by('-pk') CREATEnew views articles/urls.py 12345678from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'),] articles/views.py 12def new(request): return render(request, 'articles/new.html') templates/articles/new.html 123456789101112131415{% extends 'base.html' %}{% block content %} &lt;h1 class=&quot;fw-bold&quot;&gt;NEW&lt;/h1&gt; &lt;form action=&quot;{% url 'articles:create' %}&quot; method=&quot;post&quot;&gt; {% csrf_token %} &lt;label for=&quot;title&quot;&gt;TITLE: &lt;/label&gt; &lt;input type=&quot;text&quot; name='title'&gt; &lt;br&gt; &lt;label for=&quot;content&quot;&gt;CONTENT: &lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;content&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;작성&quot;&gt; &lt;/form&gt; &lt;a href=&quot;{% url 'articles:index' %}&quot; class=&quot;text-decoration-none&quot;&gt;BACK&lt;/a&gt;{% endblock content %} create views articles/urls.py 123456789from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'), path('create/', views.create, name='create'),] articles/views.py 123456def create(request): article = Article() article.title = request.POST.get('title') article.content = request.POST.get('content') article.save() return redirect('articles:detail', article.id) create 후 detail 페이지로 이동하도록 redirect DETAIL articles/urls.py 12345678910from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'), path('create/', views.create, name='create'), path('detail/&lt;int:article_id&gt;/', views.detail, name='detail'),] articles/views.py 123456def detail(request, article_id): article = get_object_or_404(Article, id=article_id) context = { 'article': article, } return render(request, 'articles/detail.html', context) templates/articles/detail.html 123456789101112131415161718{% extends 'base.html' %}{% block content %} &lt;h1 class=&quot;fw-bold&quot;&gt;DETAIL&lt;/h1&gt; &lt;hr&gt; &lt;h2&gt;{{ article.title }}&lt;/h2&gt; &lt;div&gt;{{ article.content }}&lt;/div&gt; &lt;br&gt; &lt;p&gt;작성일 : {{ article.created_at }}&lt;/p&gt; &lt;p&gt;수정일 : {{ article.updated_at }}&lt;/p&gt; &lt;div class=&quot;d-flex&quot;&gt; &lt;a href=&quot;{% url 'articles:edit' article.id %}&quot; class=&quot;text-decoration-none align-self-center&quot;&gt;EDIT&lt;/a&gt; &lt;form action=&quot;{% url 'articles:delete' article.id %}&quot; method=&quot;post&quot;&gt; {% csrf_token %} &lt;button class=&quot;btn btn-link text-decoration-none&quot;&gt;DELETE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;a href=&quot;{% url 'articles:index' %}&quot; class=&quot;text-decoration-none&quot;&gt;BACK&lt;/a&gt;{% endblock content %} EDIT articles/urls.py 1234567891011from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'), path('create/', views.create, name='create'), path('detail/&lt;int:article_id&gt;/', views.detail, name='detail'), path('edit/&lt;int:article_id&gt;', views.edit, name='edit'),] articles/views.py 1234567def edit(request, article_id): article = get_object_or_404(Article, id=article_id) context = { 'article': article, } return render(request, 'articles/edit.html', context) templates/articles/edit.html 123456789101112131415{% extends 'base.html' %}{% block content %} &lt;h1 class=&quot;fw-bold&quot;&gt;EDIT&lt;/h1&gt; &lt;form action=&quot;{% url 'articles:update' article.id %}&quot; method=&quot;post&quot;&gt; {% csrf_token %} &lt;label for=&quot;title&quot;&gt;TITLE: &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;{{ article.title }}&quot;&gt; &lt;br&gt; &lt;label for=&quot;content&quot;&gt;CONTENT: &lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;content&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;{{ article.content }}&lt;/textarea&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;수정&quot;&gt; &lt;/form&gt; &lt;a href=&quot;{% url 'articles:index' %}&quot;&gt;BACK&lt;/a&gt;{% endblock content %} UPDATE articles/urls.py 123456789101112from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'), path('create/', views.create, name='create'), path('detail/&lt;int:article_id&gt;/', views.detail, name='detail'), path('edit/&lt;int:article_id&gt;', views.edit, name='edit'), path('update/&lt;int:article_id&gt;', views.update, name='update'),] articles/views.py 123456def update(request, article_id): article = get_object_or_404(Article, id=article_id) article.title = request.POST.get('title') article.content = request.POST.get('content') article.save() return redirect('articles:detail', article.id) CREATE 와 마찬가지로 별도의 ‘글이 수정되었습니다’ 라는 메시지를 출력하는 template 는 필요하지 않음 DELETE articles/urls.py 12345678910111213from django.urls import pathfrom . import viewsapp_name = 'articles'urlpatterns = [ path('', views.index, name='index'), path('new/', views.new, name='new'), path('create/', views.create, name='create'), path('detail/&lt;int:article_id&gt;/', views.detail, name='detail'), path('edit/&lt;int:article_id&gt;', views.edit, name='edit'), path('update/&lt;int:article_id&gt;', views.update, name='update'), path('delete/&lt;int:article_id&gt;', views.delete, name='delete'),] articles/views.py 1234567def delete(request, article_id): article = get_object_or_404(Article, id=article_id) if request.method == 'POST': # HTTP method POST 시에만 삭제하도록 조건 작성 article.delete() return redirect('articles:index') else: return redirect('articles:detail', article.id) 정리 Model 웹 애플리케이션의 데이터를 구조화하고 조작하기 위한 도구 ⭐ 필드, 옵션 Database 체계화 된 데이터의 모임 (집합) Migrations⭐ Django가 model 에 생긴 변화 (필드를 추가, 모델 삭제 등) 를 반영하는 방법 ORM OOP 언어를 사용하여 데이터베이스와 OOP 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법 ⭐CRUD Database API DB 를 조작하기 위한 도구 (QuerySet API, CRUD) Admin Site 사용자가 아닌 서버의 관리자가 활용하기 위한 페이지","link":"/2022/03/10/Django-CRUD-with-views/"},{"title":"Django&gt;model","text":"Model⭐ 단일한 데이터에 대한 정보를 가짐 사용자가 저장하는 데이터들의 필수적인 필드들과 동작들을 포함 저장된 데이터베이스의 구조 (layout) django는 model을 통해 데이터에 접속하고 관리 일반적으로 각각의 model은 하나의 데이터베이스 테이블에 매핑 됨 Database 데이터베이스(DB) 체계화된 데이터의 모임 쿼리 (Query) 데이터를 조회하기 위한 명령어 조건에 맞는 데이터를 추출하거나 조작하는 명령어 “Query를 날린다” -&gt; DB를 조작한다. 데이터베이스 관리 시스템 종류 MySQL ORACLE db MariaDB PostgreSQL Database의 기본 구조 스키마 (Shcema) 데이터베이스에서 자료의 구조, 표현방법, 관계 등을 정의한 구조(structure) 데이터데이스의 구조와 제약 조건(자료의 구조, 표현방법, 관계)에 관련한 전반적인 명세를 기술한 것 관계 (1:N, N:N,…) 테이블(table) 열과 행의 모델을 사용해 조직된 데이터 요소들의 집합. SQL 데이터베이스에서는 테이블을 관계라고도 한다. 열(column) : 필드(field) or 속성 각 열에는 고유한 데이터 형식이 지정된다. INTEGER, TEXT, NULL 등 행(row) : 레코드(record) or 튜플 테이블의 데이터는 행에 저장된다. PK (기본키)⭐ 각 행의 고유값으로 Primary Key로 불린다. 반드시 설정하여야하며, 데이터베이스 관리 및 관계 설정 시 주요하게 활용된다. django는 id가 곧 PK이다. Model 웹 애플리케이션의 데이터를 구조화하고 조작하기 위한 도구⭐ ORM⭐ Object-Relational-Mapping 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간(Django-SQL)에 데이터를 변환하는 프로그래밍 기술 OOP프로그래밍에서 RDBMS을 연동할 때, 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법 Django는 내장 Django ORM 을 사용함 ORM의 장점과 단점⭐ 장점 SQL을 잘 알지 못해도 DB 조작이 가능 SQL의 절차적 접근이 아닌 객체지향적 접근으로 인한 높은 생산성 단점 ORM 만으로 완전한 서비스를 구현하기 어려운 경우가 있음 현대 웹 프레임워크의 요점은 웹 개발의 속도를 높이는 것 (생산성) 개발 속도는 ORM을 쓰는 것이 더 빠르지만, 서비스의 속도는 SQL을 직접 사용하는 것이 더 빠르다. 서비스 런칭 자체는 ORM을 사용하고 서비스를 운영하며 시간이 많이걸리는 부분을 SQL로 최적화 하는 방법을 많이 사용한다. 왜 ORM 을 사용할까? DB를 객체로 조작하기 위해 ORM을 사용한다. model.py 작성1234# articles/models.pyclass Article(models.Model): title = models.CharField(max_length=10) # 길이제한 있는 경우 CharField 사용 content = models.TextField() # 길이제한 없는 경우 TextField 사용 각 모델은 django.db.models.Model 클래스의 서브 클래스로 표현 django.db.models.Model 모듈의 Model 클래스를 상속받음 models 모듈을 통해 어떠한 타입의 DB 컬럼을 정의할 것인지 정의 title과 content는 모델의 필드를 나타냄 각 필드는 클래스 속성으로 지정되어 있으며, 각 속성은 각 데이터베이스의 열에 매핑 Model 명 정할땐 단수형으로 생성한다. Django에서 자동으로 복수형을 붙여서 관리해주기 때문이다. 사용 모델 필드⭐ CharField(max_length=None, **options) 길이의 제한이 있는 문자열을 넣을 때 사용 CharField의 max_length는 필수 인자 필드의 최대 길이(문자), 데이터베이스 레벨과 Django의 유효성 검사(값을 검증하는 것)에서 활용 TextField(**options) 글자의 수가 많을 때 사용 max_length 옵션 작성 시 자동 양식 필드인 textarea 위젯에 반영은 되지만 모델과 데이터베이스 수준에는 적용되지 않음 max_length 사용은 CharField에서 사용해야 함 Migrations⭐⭐⭐ django가 model에 생긴 변화를 DB에 반영하는 방법 commands⭐⭐ 마이그레이션 실행 및 DB 스키마를 다루기 위한 몇가지 명령어 (python manage.py [command]) makemigrations model을 변경한 것에 기반한 새로운 마이그레이션(like 설계도)을 만들 때 사용 ‘migrations/0001_initial.py’ 생성 확인 migrate 마이그레이션을 DB에 반영하기 위해 사용 설계도를 실제 DB에 반영하는 과정 모델에서의 변경 사항들과 DB의 스키마가 동기화를 이룸 0001_initial.py 설계도를 실제 DB에 반영 sqlmigrate python manage.py sqlmigrate app_name 0001⭐ 마이그레이션에 대한 SQL 구문을 보기 위해 사용 해당 migrations 설계도가 SQL 문으로 어떻게 해석되어 동작할 지 미리 확인할 수 있음 showmigrations 프로젝트 전체의 마이그레이션 상태를 확인하기 위해 사용 migrations 설계도들이 migrate 됐는지 안됐는지 여부를 확인할 수 있음 추가 모델 필드 작성실습1234567891011121314# articles/models.pyclass Article(models.Model): created_at = models.DateTimeField(auto_now_add=True) # auto_now_add 데이터가 생성될 때 시간을 자동으로 저장 updated_at = models.DateTimeField(auto_now=True) # auto_now 현재 시간을 자동으로 저장## 참고 ## # 다른 필드들에 대해서 default 값을 설정하는 대신# 필드열을 비워두는 것을 허용한다는 의미로 다음과 같이 설정가능하다.# age = models.IntegerField(null=True)# null=True : (NULL)# blank=True : ('') 모델에서 필드정보 수정되면 makemigrations 진행 123456$ python manage.py makemigrationsYou are trying to add the field 'created_at' with 'auto_now_add=True' to student without a default; the database needs something to populate existing rows. 1) Provide a one-off default now (will be set on all existing rows) 2) Quit, and let me add a default in models.pySelect an option: 테이블을 만들 때 created_at 필드에 대한 default 값이 없어서 선택하도록 bash에 출력됨⭐⭐ 1 : django에서 지금 바로 기본값을 설정해줌 2 : makemigrations 종료하고 py파일에서 직접 default 값 설정함 DataField’s options⭐⭐⭐ auto_now_add 최초 생성 일자 Django ORM 이 최초 insert (테이블에 데이터 입력)시에만 현재 날짜와 시간으로 갱신(테이블에 어떤 값을 최초로 넣을 때) auto_now 최종 수정 일자 Django ORM이 save를 할 때마다 현재 날짜와 시간으로 갱신 DateTimeField가 아닌 DataField의 options를 확인한 이유 DataTimeField는 DateField와 동일한 추가 인자(extra argument)를 사용함 DataTimeField는 DateField의 서브 클래스 반드시 기억해야 할 migration 3단계 models.py model 변경사항 발생 시 $ python manage.py makemigrations migrations 파일 생성 $ python manage.py migrate DB 반영(모델과 DB의 동기화) Database API “DB를 조작하기 위한 도구” Django가 기본적으로 ORM을 제공함에 따른 것으로 DB를 편하게 조작할 수 있도록 도움 Model을 만들면 Django는 객체들을 만들고 읽고 수정하고 지울 수 있는 database-abstract API를 자동으로 만듦 database-abstract API 혹은 database-access API라고도 함 QuerySet API reference Making Queries [클래스명].objects.[메서드] DB API Manager Django 모델에 데이터베이스 query 작업이 제공되는 인터페이스 기본적으로 모든 Django 모델 클래스에 objects 라는 Manager 를 추가 QuerySet 데이터베이스로부터 전달받은 객체 목록 queryset 안에 객체는 0개, 1개 혹은 여러 개일 수 있음 데이터베이스로부터 조회, 필터, 정렬 등을 수행할 수 있음 Django shell 일반 python shell 을 통해서는 장고 프로젝트 환경에 접근할 수 없음 그래서 장고 프로젝트 설정이 load된 python shell 을 활용해 DB API 구문 테스트 진행 기본 Django shell보다 더 많은 기능을 제공하는 shell_plus를 사용해서 진행 라이브러리 설치 12$ pip install ipython$ pip install django-extensions 라이브러리 등록 및 실행 123456# settings.pyINSTALLED_APPS = [ ..., 'django_extensions', ...,] 1$ python manage.py shell_plus CRUD⭐ 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete 를 묶어서 일컫는 말 CREATE⭐12345678910111213# 방법 1. 인스턴스 생성 후 인스턴스 변수 설정&gt;&gt;&gt; article = Article()&gt;&gt;&gt; article.title = 'first'&gt;&gt;&gt; article.django = 'django!'&gt;&gt;&gt; article.save()# 방법 2. 초기 값과 함께 인스턴스 생성&gt;&gt;&gt; article = Article(title='first', content='django!')&gt;&gt;&gt; article.save()# 방법 3. QuerySet API - create() 사용# 위 2개 방식과는 다르게 바로 DB 에 저장되며 쿼리 표현식을 리턴한다.&gt;&gt;&gt; Article.objects.create(title='first', content='django!') 인스턴스를 생성 후 인스턴스 변수 설정 초기 값과 함께 인스턴스 생성 QuerySet API - create() 사용 save() method Saving objects 객체를 데이터베이스에 저장함 데이터 생성 시 save() 를 호출하기 전에는 객체의 ID 값이 무엇인지 알 수 없음 ID 값은 Django 가 아니라 DB에서 계산되기 때문 단순히 모델을 인스턴스화 하는 것은 DB에 영향을 미치지 않기 때문에 반드시 save() 가 필요 __str__ : print 호출 시 출력되는 문자열, 작성 후 반드시 shell_plus 를 재시작해야 반영된다. READ1234# DB에 인스턴스 객체를 얻기 위한 쿼리문 날리기# 이때, 레코드가 하나만 있으면 인스턴스 객체고, 두개 이상이면 쿼리셋으로 리턴&gt;&gt;&gt; Ariticle.objects.all()&lt;QuerySet []&gt; all() 현재 QuerySet의 복사본을 반환 get() 주어진 lookup 매개변수와 일치하는 객체를 반환 객체를 찾을 수 없으면 DoesNotExist 예외를 발생시키고, 둘 이상의 객체를 찾으면 MultipleObjectsReturned 예외를 발생 시킴 위와 같은 특징을 가지고 있기 때문에 primary key 와 같이 고유(unique)성을 보장하는 조회에서 사용해야 함 12from django.shortcuts import render, get_object_or_404stu = get_object_or_404(Student, pk=1) filter() 주어진 lookup 매개변수와 일치하는 객체를 포함하는 새 QuerySet을 반환 ⭐ 각각의 리턴받는 값 헷갈리지 않도록 주의 UPDATE⭐123456789&gt;&gt;&gt; article = Article.objects.get(pk=1)&gt;&gt;&gt; article.title'first'&gt;&gt;&gt; article.title = 'byebye'&gt;&gt;&gt; article.save()&gt;&gt;&gt; article.title'byebye' DB에서 수정할 data를 가져온다. 가져온 데이터의 값을 변경한다. save 한다. DELETE1234&gt;&gt;&gt; article = Article.objects.get(pk=1)&gt;&gt;&gt; article.delete()&gt;&gt;&gt; Article.objects.get(pk=1)DoesNotExist: Article matching query does not exist. delete() QuerySet 의 모든 행에 대해 SQL 삭제 쿼리를 수행하고, 삭제된 객체 수와 객체 유형당 삭제 수가 포함된 딕셔너리를 반환 Field lookups 조회 시 특정 검색 조건을 지정 QuerySet 메서드 filter(), exclude() 및 get() 에 대한 키워드 인수로 지정됨 12Article.objects.filter(pk__gt=2)Article.objects.filter(content__contains='ja') 💡 데이터 베이스 조작을 위한 다양한 QuerySet API methods 는 해당 공식문서를 반드시 참고하여 학습할 것 https://docs.djangoproject.com/en/3.2/ref/models/querysets/# Admin SiteAutomatic admin interface 사용자가 아닌 서버의 관리자가 활용하기 위한 페이지 Model class 를 admin.py 에 등록하고 관리 django.contrib.auth 모듈에서 제공됨 record 생성 여부 확인에 매우 유용하며, 직접 record를 삽입할 수도 있음 admin 생성⭐1$ python manage.py createsuperuser 관리자 계성 생성 후 서버를 실행한 다음 ‘/admin’ 으로 가서 관리자 페이지 로그인 계정만 만든 경우 Django 관리자 화면에서 아무것도 보이지 않음 내가 만든 Model 을 보기 위해서는 admin.py 에 작성하여 Django 서버에 등록 ❗️auth에 관련된 기본 테이블이 생성되지 않으면 관리자 계정을 생성할 수 없음 admin 등록123456789# article/admin.pyfrom django.contrib import adminfrom .models import Articleclass ArticleAdmin(admin.ModelAdmin): list_display = ('pk', 'title', 'content', 'created_at', 'updated_at',)# ⭐ admin site에 register 하겠다.admin.site.register(Article) admin.py는 관리자 사이트에 Article 객체가 관리자 인터페이스를 가지고 있다는 것을 알려주는 것 models.py에 정의한 __str__ 의 형태로 객체가 표현됨 list_display : models.py 정의한 각각의 속성(칼럼)들의 값(레코드)을 admin 페이지에 출력하도록 설정","link":"/2022/03/08/Django-model/"},{"title":"Django","text":"Web FrameworkDjangoDjango is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. Web World Wide Web 인터넷에 연결된 컴퓨터를 통해 정보를 공유할 수 있는 전 세계적인 정보 공간 ⭐ 정적페이지와 동적페이지 차이 Static web page (정적 웹 페이지) 서버에 미리 저장된 파일이 사용자에게 그대로 전달되는 웹페이지 서버가 정적 웹 페이지에 대한 요청을 받은 경우 서버는 추가적인 처리 과정 없이 클라이언트에게 응답을 보냄 모든 상황에서 모든 사용자에게 동일한 정보를 표시 일반적으로 HTML, CSS, JavaScript 로 작성됨 flat page 라고도 함 Dynamic web page (동적 웹 페이지) 웹 페이지에 대한 요청을 받은 경우 서버는 추가적인 처리 과정 이후 클라이언트에게 응답을 보냄 동적 페이지는 방문자와 상호작용하기 때문에 페이지 내용은 그때그때 다름 서버사이드 프로그래밍 언어 (Python, java, C++등)가 사용되며 파일을 처리하고 데이터베이스와의 상호작용이 이루어짐 Framework 프로그래밍에서 특정 운영 체제를 위한 응용 프로그램 표준 구조를 구현하는 클래스와 라이브러리 모임 재사용할 수 있는 수많은 코드를 프레임워크로 통합함으로써 개발자가 새로운 애플리케이션을 위한 표준 코드를 다시 작성하지 않아도 같이 사용할 수 있도록 도움 Application Framework 라고도 함 Web framework 웹 페이지를 개발하는 과정에서 겪는 어려움을 줄이는 것이 주 목적으로 데이터베이스 연동, 템플릿 형태의 표준, 세션 관리, 코드 재사용 등의 기능을 포함 동적인 웹페이지나, 웹 애플리케이션, 웹 서비스 개발 보조용으로 만들어지는 Application Framework 의 일종 Django를 사용해야 하는 이유 검증된 Python 언어 기반 Web framework 대규모 서비스에도 안정적이며 오랫동안 세계적인 기업들에 의해 사용됨 spotify, Instagram, Dropbox, Delivery Hero… Framework Architecture MVC Design Pattern (model-view-controller) 소프트웨어 공학에서 사용되는 디자인 패턴 중 하나 사용자 인터페이스로부터 프로그램 로직을 분리하여 애플리테이션의 시각적 요소나 이면에서 실행되는 부분을 서로 영향없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있음 Django 는 MTV Pattern (model-template-view) 이라고 함 MTV Pattern⭐ Model 응용프로그램의 데이터 구조를 정의하고 데이터베이스의 기록을 관리(추가, 수정, 삭제) Template 파일의 구조나 레이아웃을 정의 실제 내용을 보여주는데 사용 (Presentation) View HTTP 요청을 수신하고 HTTP 응답을 반환 Model 을 통해 요청을 충족시키는데 필요한 데이터에 접근 template 에게 응답의 서식 설정을 맡김 MVC Pattern MTV (Django) Model Model View Template Controller View Django Intro가상환경 설정12345678$ python -m venv venv # 파이썬 venv 라는 모듈을 실행한다. 뒤에 있는 venv 는 가상환경 이름$ source venv/Script/activate(venv)$ pip listPackage Version---------- -------pip 21.2.4setuptools 58.1.0 vs code 에서 설정 및 확인 방법 ctrl + shift + p : python select interpreter 에서 현재 디렉토리의 python version 선택 ❗️ 가상환경은 git으로 관리하지 않는다. gitignore 작성 시 venv 추가 pip freeze &gt; requirements.txt 목록으로 관리 이렇게 생성된 requirements.txt 파일을 git에 올린다. 💡 requirements.txt로 가상환경 설정하는 법 pip install -r requirements.txt Django 시작하기 Django 설치 전 가상환경 생성 및 활성화 Django 설치 (현재 3.2버전이 LTS) LTS (Long Term Support) 일반적인 경우보다 장기간에 걸쳐 지원하도록 고안된 소프트웨어의 버전 컴퓨터 소프트웨어의 제품 수명주기 관리 정책 배포자는 LTS 확정을 통해 장기적이고 안정적인 지원을 보장함 ❗️2021년 21월 Django 4.0 릴리즈 이후 버전을 명시하지 않으면 4.0 버전이 설치되니 주의! 12345678910$ pip install django==3.2.12$ pip listPackage Version---------- -------asgiref 3.5.0Django 3.2.12pip 21.2.4pytz 2021.3setuptools 58.1.0sqlparse 0.4.2 프로젝트 생성⭐ django-admin startproject &lt;프로젝트명&gt; . 프로젝트 이름에는 python이나 django 에서 사용중인 키워드를 피해야 한다. ‘-‘ (하이픈) 도 사용할 수 없다. . 을 붙이지 않으면 manage.py 파일이 프로젝트 파일 아래에 생긴다. 서버 시작하기(활성화) python manage.py runserver http://127.0.0.1:8000/ 접속 시 다음과 같은 창 뜨면 서버 정상적으로 활성화 된 것 프로젝트 구조⭐ __init__.py : Python 에게 이 디렉토리를 하나의 Python 패키지로 다루도록 지시 asgi.py : Asynchronous Server Gateway Interface, django 애플리케이션이 비동기식 웹 서버와 연결 및 소통하는 것을 도움 settings.py : 애플리케이션의 모든 설정을 포함 urls.py : 사이트의 url 과 적절한 views의 연결을 지정 wsgi.py : Web Server Gateway Interface, django 애플리케이션이 웹서버와 연결 및 소통하는 것을 도움 manage.py : django 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티 Application 생성 일반적으로 Application명은 복수형으로 하는 것을 권장 1$ python manage.py startapp articles Application 구조⭐ admin.py : 관리자용 페이지를 설정 하는 곳 apps.py : 앱의 정보가 작성된 곳 models.py : 앱에서 사용하는 Model 을 정의하는 곳 tests.py : 프로젝트의 테스트 코드를 작성하는 곳 views.py : view 함수들이 정의 되는 곳 ⭐ urls.py 는 app생성시에는 자동 생성되지 않는다. Project &amp; Application ⭐ Project 프로젝트는 앱의 집합 (collection of apps) 프로젝트는 여러 앱이 포함될 수 있음 앱은 여러 프로젝트에 있을 수 있음 Application 앱은 실제 요청을 처리하고 페이지를 보여주고 하는 등의 역할을 담당 하나의 프로젝트는 여러 앱을 가짐 일반적으로 앱은 하나의 역할 및 기능 단위로 작성함 앱(Application) 등록 프로젝트에서 앱을 사용하기 위해서는 반드시 INSTALLED_APPS리스트에 추가해야함 settings.py에 위치 Django installation 에 활성화 된 모든 앱을 지정하는 문자열 목록 123456789INSTALLED_APPS = [ 'articles', # 첫번째에 application 명 추가! 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 💡반드시 생성 후 등록!⭐ INSTALLED_APPS에 먼저 등록하고 생성하려면 앱이 생성되지 않음 요청과 응답URLs (urls.py) HTTP 요청(request)을 알맞은 view로 전달⭐ urls.py에서 urlpatterns 리스트에 view 추가 123456789# firstpjt/urls.pyfrom django.contrib import adminfrom django.urls import pathfrom articles import views # articles 의 views 모듈 importurlpatterns = [ path('admin/', admin.site.urls), path('index/', views.index), #views의 index 함수 호출] Django 에서는 trailing comma를 권장 list 마지막의 , 생산성 향상을 위함 View⭐ HTTP 요청을 수신하고 HTTP 응답을 반환하는 함수 작성 Model 을 통해 요청에 맞는 필요 데이터에 접근 Template에게 HTTP 응답 서식을 맡김 views.py에서 view 함수 생성 123456# articles/views.pyfrom django.shortcuts import render# Create your views here.def index(request): return render(request, 'index.html') Templates⭐ 실제 내용을 보여주는데 사용되는 파일 파일의 구조나 레이아웃을 정의 (ex. HTML) Template 파일 경로의 기본값은 app 폴더 안의 templates 폴더로 지정되어 있음 application 폴더에서 templates 폴더 생성 후 index.html파일 추가 서버 실행 후 http://127.0.0.1:8000/index/ 접속하면 index.html 작성 내용 확인 가능 추가 설정 (settings.py)⭐ LANGUAGE_CODE LANGUAGE_CODE = 'ko-kr' 모든 사용자에게 제공되는 번역을 결정 이 설정이 적용되려면 USE_I18N이 활성화 되어있어야 함 TIME_ZONE 데이터베이스 연결의 시간대를 나타내는 문자열 지정 USE_TZ가 True 이고 이 옵션이 설정된 경우 데이터베이스에서 날짜 시간을 읽으면, UTC 대신 새로 설정한 시간대의 인식 날짜&amp;시간이 반환 됨 USE_I18N Django 의 번역 시스템을 활성화해야 하는지 여부를 지정 USE_L10N 데이터의 지역화 된 형식(localized formatting) 을 기본적으로 활성화할지 여부를 지정 True일 경우, Django는 현재 locale 의 형식을 사용하여 숫자와 날짜를 표시 USE_TZ datetimes 가 기본적으로 시간대를 인식하는지 여부를 지정 True일 경우 Django 는 내부적으로 시간대 인식 날짜/시간을 사용 TemplateDjango Template 데이터 표현을 제어하는 도구이자 표현에 관련된 로직 사용하는 built-in system Django template language (DTL) Django Template Language (DTL)⭐ Django template 에서 사용하는 built-in template system 조건, 반복, 변수 치환, 필터 등의 기능을 제공 단순히 Python 이 HTML에 포함된 것이 아니며, 프로그래밍적 로직이 아니라 프레젠테이션을 표현하기 위한 것 Python 처럼 일부 프로그래밍 구조(it, for등)를 사용할 수 있지만, 이것은 해당 Python 코드로 실행되는 것이 아님! https://docs.djangoproject.com/en/3.2/ref/templates/builtins/ ⭐⭐⭐ DTL Syntax⭐ Variable {{ variable }} render()를 사용하여 views.py 에서 정의한 변수를 template 파일로 넘겨 사용하는 것 변수 명은 영어, 숫자와 밑줄(_)의 조합으로 구성될 수 있으나 밑줄로는 시작할 수 없음 공백이나 구두점 문자 또한 사용할 수 없음 dot(.)를 사용하여 변수 속성에 접근할 수 있음 render()의 세번째 인자로 {'key': value} 와 같이 딕셔너리 형태로 넘겨주며,여기서 정의한 key 에 해당하는 문자열이 template 에서 사용 가능한 변수명(variable)이 됨 Filters {{ variable|filter}} 표시할 변수를 수정할 때 사용 60개의 built-in template filters 를 제공 chained 가 가능하며 일부 필터는 인자를 받기도 함 Tags {% tag %} 출력 텍스트를 만들거나, 반복 또는 논리를 수행하여 제어 흐름을 만드는 등 변수보다 복잡한 일들을 수행 일부 태그는 시작과 종료태그가 필요 {% if %}{% endif %} 약 24개의 built-in template tags 를 제공 Comments 한줄 주석 : `` 여러줄 주석: {% comment %}{% endcomment %} 코드 작성 순서 데이터의 흐름에 맞추어 작성 urls.py -&gt; views.py -&gt; templates Template inheritance (템플릿 상속) 템플릿 상속은 기본적으로 코드의 재사용성에 초점을 맞춤 템플릿 상속을 사용하면 사이트의 모든 공통 요소를 포함하고, 하위 템플릿이 재정의(override) 할 수 있는 블록을 정의하는 기본 “skeleton” 템플릿을 만들 수 있음 1234567# settings.pyTEMPLATES = [ { ... 'DIRS' : [BASE_DIR / 'templates'], ###⭐### },] Template Tag⭐ {% extends '' %} 자식(하위) 템플릿이 부모 템플릿을 확장한다는 것을 알림 ⭐️반드시 템플릿 최상단에 작성 되어야 함 {% block content %} {% endblock %} 하위 템플릿에서 재지정(overridden)할 수 있는 블록을 정의 즉, 하위 템플릿이 채울 수 있는 공간 {% include '' %} 템플릿을 로드하고 현재 페이지로 렌더링 템플릿 내에 다른 템플릿을 포함하는 방법 주로 파일명 앞에 ‘_’(언더바)를 붙여 include 되는 템플릿을 분류함 Django template system (feat. Django 설계 철학) 표현과 로직(view)을 분리 템플릿 시스템은 표현을 제어하는 도구이자 표현에 관련된 로직일 뿐이라고 생각한다. 즉, 템플릿 시스템은 이러한 기본목표를 넘어서는 기능을 지원하지 말아야 한다. 중복을 배제 대다수의 동적 웹사이트는 공통 header, footer, navbar 같은 사이트 공통 디자인을 갖는다. Django 템플릿 시스템을 이러한 요소를 한 곳에 저장하기 쉽게 하여 중복 코드를 없애야 한다. 이것이 템플릿 상속의 기초가 되는 철학이다. HTML FormHTML “form” element 웹에서 사용자 정보를 입력하는 여러 방식(text, button, checkbox, file, hidden, image, password, radio, reset, submit)을 제공하고, 사용자로부터 입력받은 데이터를 서버로 전송하는 역할을 담당 핵심 속성 (attribute)⭐ action : 입력된 데이터가 전송될 URL 지정 method : 입력 데이터 전달 방식 지정 HTML “input” element 사용자로부터 데이터를 입력 받기 위해 사용 type 속성에 따라 동작 방식이 달라짐 핵심 속성 (attribute) name⭐ 중복 가능, 양식을 제출했을 때 name 이라는 이름에 설정된 값을 넘겨서 값을 가져올 수 있음 주요 용도는 GET/POST 방식으로 서버에 전달하는 파라미터 (name은 key, value는 value)로 매핑하는 것 GET 방식에서는 URL 에서 ?key=value&amp;key=value형식으로 데이터를 전달함 HTML “label” element 사용자 인터페이스 항목에 대한 설명 (caption)을 나타냄 label 을 input 요소와 연결하기 input 에 id 속성 부여 label 에는 input 의 id와 동일한 값의 for 속성이 필요 label 과 input 요소 연결의 주요 이점 시각적인 기능 뿐만 아니라 화면 리더기에서 label 을 읽어 사용자가 입력해야 하는 텍스트가 무엇인지 더 쉽게 이해할 수 있도록 돕는 프로그래밍적 이점도 있음 label 을 클릭해서 input 에 초점(focus)를 맞추거나 활성화(activate) 시킬 수 있음 HTML “for” attribute for 속성의 값과 일치하는 id를 가진 문서의 첫번째 요소를 제어 연결된 요소가 labelable elements 인 경우 이 요소에 대한 labeled control 이 됨 labelable elements? label 요소와 연결할 수 있는 요소 button, input(not hidden type), select, textarea, … HTML “id” attribute 전체 문서에서 고유(must be unique)해야 하는 식별자를 정의 사용 목적 linking, scripting, styling 시 요소를 식별 HTTP HyperText Transfer Protocol 웹에서 이루어지는 모든 데이터 교환의 기초 주어진 리소스가 수행 할 작업을 나타내는 request methods를 정의 HTTP request method 종류 GET, POST, PUT, DELETE … django 에서는 GET과 POST 만 지원 HTTP request method - “GET” 서버로부터 정보를 조회하는 데 사용 데이터를 가져올 때만 사용해야 함 데이터를 서버로 전송할 때 body 가 아닌 Query String Parameters 를 통해 전송 Query String Parameters : 주소로 데이터가 전달되는 형태 (?key=value&amp;key=value) 우리는 서버에 요청을 하면 HTML 문서 파일 한장을 받는데, 이때 사용하는 요청의 방식이 GET URLDjango URLs Dispatcher (발송자, 운항 관리자)로서의 URL 웹 애플리케이션은 URL 을 통한 클라이언트의 요청에서부터 시작됨 Variable Routing⭐ django에서는 'Dispatcher'로 검색 URL 주소를 변수로 사용하는 것 (url 주소에서 일부에다가 data를 담아서 보내는 것) URL 의 일부를 변수로 지정하여 view 함수의 인자로 넘길 수 있음 즉, 변수 값에 따라 하나의 path()에 여러 페이지를 연결 시킬 수 있음 123path('accounts/user/&lt;int:user_pk&gt;/', ...)# accounts/users/1 -&gt; 1번 user 관련 페이지# accounts/users/2 -&gt; 2번 user 관련 페이지 URL Path converters⭐ 자동으로 설정한 타입으로 형변환해서 전달해준다. str '/' 를 제외하고 비어있지 않은 모든 문자열과 매치 작성하지 않을 경우 기본 값 (되도록 명시하자!) int 0 또는 양의 정수와 매치 slug ASCII 문자 또는 숫자, 하이픈 및 밑줄 문자로 구성된 모든 슬러그 문자열과 매치 ex ) ‘building-your-1st-django-site’ uuid path App URL mapping app의 view 함수가 많아지면서 사용하는 path() 또한 많아지고, app 또한 더 많이 작성되기 때문에 프로젝트의 urls.py 에서 모두 관리하는 것은 프로젝트 유지보수에 좋지 않음 이제는 각 app에 urls.py를 작성하게 됨 12345678910111213# articles/urls.py 기본 형태from django.urls import pathfrom . import views # django 는 명시적 상대경로(from .module import ..) 를 권장urlpatterns = []# ../urls.pyfrom django.urls import path, includeurlpatterns = [ # urlpatterns는 언제든지 다른 URLconf 모듈을 포함(include)할 수 있음 ... path('articles/', include('articles.urls')),] include()⭐ 다른 URLconf(app1/urls.py) 들을 참조할 수 있도록 도움 함수 include() 를 만나게 되면, URL 의 그 시점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속처리를 위해 include 된 URLconf로 전달 django 는 명시적 상대경로(from .module import ..) 를 권장 Naming URL patterns⭐ 이제는 링크에 URL 을 직접 작성하는 것이 아니라 path() 함수의 name 인자를 정의해서 사용 Django Template Tag 중 하나인 url 태그를 사용해서 path() 함수에 작성한 name을 사용할 수 있음 url 설정에 정의된 특정한 경로들의 의존성을 제거할 수 있음 12345# urls.py에서 다음과 같이 설정path('index/', views.index, name='index'),# html에서의 사용&lt;a href=&quot;{% url 'index' %}&quot;&gt;메인 페이지&lt;/a&gt; {% url ' ' %} 주어진 URL 패턴 이름 및 선택적 매개 변수와 일치하는 절대경로주소를 반환 템플릿에 URL 을 하드코딩하지 않고도 DRY 원칙을 위반하지 않으면서 링크를 출력하는 방법 DRY (Don’t Repeat Yourself)","link":"/2022/03/02/Django/"},{"title":"JavaScript","text":"바닐라 JS로 크롬 앱 만들기 - Javascript for Beginners https://nomadcoders.co/javascript-for-beginners 1. 변수 선언123const a = 1;let b = 2;var c = 3; const : 재선언 금지, 재할당 금지 let : 재선언 금지, 재할당 가능 var : 재선언 가능, 재할당 가능 2. Object123456const player = { name: &quot;nico&quot;, say: function(otherPersonName) { return &quot;Hello &quot; + otherPersonName + &quot; nice to meet you!&quot; },}; 3. querySelector()MND : https://developer.mozilla.org/ko/docs/Web/API/Document/querySelector 123&lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;Grab me!&lt;/h1&gt;&lt;/div&gt; 1const title = document.querySelector(&quot;.hello h1&quot;);","link":"/2022/03/20/JavaScript/"},{"title":"OS&gt;01.운영체제 개요","text":"CS/알고리즘 스터디에서 진행한 OS 스터디 개인공부 내용 백업강의 링크 : 운영체제 01.운영체제 개요 운영체제는 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층으로서 모든 컴퓨터 시스템의 필수적인 부분이다. 본 강좌에서는 이와 같은 운영체제의 개념과 역할, 운영체제를 구성하는 각 요소 및 그 알고리즘의 핵심적인 부분에 대해 기초부터 학습한다. 1. 운영체제란 무엇인가?OS (Operating System) 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 운영체제의 목적 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공 컴퓨터 시스템의 자원을 효율적으로 관리 2. 컴퓨터 시스템의 구조운영체제의 기능 프로세스의 상태 프로세스 : 실행중인 프로그램 3. CPU 스케줄링 FCFS (First-Come First-Served) SJF (Shortest-Job-First) 금번 CPU 사용시간이 가장 짧은 프로세스를 제일 먼저 스케줄 minimum average waiting time을 보장 문제점 : Starvation(기아 현상) 발생 가능 RR (Round Robin) 각 프로세스는 동일 크기의 CPU 할당 시간을 가짐 할당 시간 끝나면 인터럽트 발생하여 프로세스는 CPU를 빼앗기고 CPU 큐의 제일 뒤에 줄을 섬 n개의 프로세스가 CPU 큐에 있는 경우 어떤 프로세스도 (n-1)* 할당시간 이상 기다리지 않음 대기시간이 프로세스의 CPU 사용시간에 비례 4. 메모리 관리 LRU : 가장 오래 전에 참조 페이지 삭제 LFU : 참조 횟수가 가장 적은 페이지 삭제 5. 디스크 스케줄링 FCFS (First-Come First-Served) SSTF (Shortest Seek Time First) starvation 문제 SCAN 헤드가 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다. 다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동한다. 6. 저장장치 계층구조와 캐싱 (caching) 7. 플래시메모리 8. 운영체제의 종류 서버용, PC용, 스마트디바이스용 운영체제 공개 소프트웨어 (Open Source Software) Linux, Android","link":"/2022/01/29/OS-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94/"},{"title":"OS&gt;02.컴퓨터 시스템의 구조","text":"02. 컴퓨터 시스템의 구조운영체제란? 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 협의의 운영체제 (커널) 운영체제의 핵심 부분으로 메모리에 상주하는 부분 광의의 운영체제 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념 운영 체제의 목적 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공 컴퓨터 시스템의 자원을 효율적으로 관리 프로세서, 기억장치, 입출력 장치 등의 효율적 관리 사용자간의 형평성 있는 자원 분배 주어진 자원으로 최대한의 성능을 내도록 사용자 및 운영체제 자신의 보호 프로세스, 파일, 메시지 등을 관리 ​ 운영 체제의 분류 동시 작업 가능 여부 단일 작업(single tasking) : 한 번에 하나의 작업만 처리 다중 작업(multi tasking) : 동시에 두 개 이상의 작업 처리 사용자의 수 단일 사용자 (single user) 다중 사용자 (multi user) 처리 방식 일괄 처리 (batch processing) 작업 요청의 일정량 모아서 한꺼번에 처리 작업이 완전 종료될 때까지 기다려야 함 시분할 (time sharing) 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐 (ex. UNIX) Interactive 한 방식 실시간 (Realtime OS) 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS Ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 실시간 시스템의 개념 확장 Hard realtime system (경성 실시간 시스템) Soft realtime system (연성 실시간 시스템) 몇 가지 용어 다음 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다. Multitasking Multiprogramming : 여러 프로그램이 메모리에 올라가 있음을 강조 Time sharing : CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조 Multiprocess : 하나의 컴퓨터에 CPU (processor) 가 여러개 붙어있음을 의미 운영 체제의 예 유닉스(UNIX) 서버를 위한 운영체제 코드의 대부분을 C언어로 작성 높은 이식성 최소한의 커널 구조 복잡한 시스템에 맞게 확장 용이 소스코드 공개 프로그램 개발에 용이 다양한 버전 System V, FreeBSD, SunOS, Solaris Linux DOS (Disk Operating System) MS Windows Handheld device 를 위한 OS 운영 체제의 구조 ​ 컴퓨터 시스템 구조 ​ mode bit 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치 필요 Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원 1 (사용자 모드) : 사용자 프로그램 수행 0 (모니터 모드 = 커널 모드, 시스템 모드) : OS 코드 수행 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 ‘특권 명령’으로 규정 Interrupt 나 Exception 발생 시 하드웨어가 mode bit 을 0으로 바꿈 사용자 프로그램에서 CPU를 넘기기 전에 mode bit을 1로 셋팅 registers PC (Program Counter) : 다음번 실행할 메모리의 주소를 가지고 있는 레지스터 Timer 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴 타이머는 매 클럭 틱 때마다 1씩 감소 타이머 값이 0이 되면 타이머 인터럽트 발생 CPU를 특정 프로그램이 독점하는 것으로부터 보호 타이머는 time sharing을 구현하기 위해 널리 이용됨 타이머는 현재 시간을 계산하기 위해서도 사용 Interrupt 현대의 운영체제는 인터럽트에 의해 구동됨 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다. Interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트 Trap (소프트웨어 인터럽트) Exception : 프로그램이 오류를 범한 경우 System call : 프로그램이 커널 함수를 호출하는 경우 인터럽트 관련 용어 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음 인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러) 해당 인터럽트를 처리하는 커널 함수 시스템콜(System Call) 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것 Device Controller ​ 운영체제로 CPU가 넘어오는 경우? Interrupt line을 셋팅하는 경우 하드웨어가 intterrupt 걸어서 운영체제로 cpu넘어오는 경우 소프트웨어가 직접 interrupt (시스템 콜) 걸어서 운영체제로 cpu넘어오는 경우, (ex. I/O 작업 시) Exception 발생 시 동기식 입출력과 비동기식 입출력 I/O 의 완료는 인터럽트로 알려줌 동기식 입출력 (Synchronous I/O) I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감 구현 방법 1 I/O가 끝날 때 까지 CPU를 낭비시킴 매 시점 하나의 I/O만 일어날 수 있음 구현 방법 2 I/O가 완료될 때 까지 해당 프로그램에게서 CPU를 빼앗음 I/O처리를 기다리는 줄에 그 프로그램을 줄 세움 다른 프로그램에게 CPU를 줌 비동기식 입출력 (Asynchronous I/O) I/O 가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감 ​ DMA controller![이미지6](스크린샷 2022-01-29 오전 12.37.50-3422404.png) DMA (Direct Memory Access) 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용 CPU의 중재없이 device controller가 device의 buffer storage의 내용을 메모리에 block단위로 직접 전송 바이트 단위가 아니라 block단위로 인터럽트를 발생시킴 ​ 서로 다른 입출력 기계어 I/O 를 수행하는 special instruction에 의해 Memory Mapped I/O 에 의해 저장장치 계층 구조","link":"/2022/02/05/OS-02-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0/"},{"title":"OS&gt;04.CPU 스케줄링","text":"04. CPU 스케줄링프로세스와 관련한 시스템 콜 fork() : create a child exec() : overlay new image wait() : sleep until is done 프로세스 A가 wait() 시스템 콜을 호출하면 커널은 child 가 종료될 때 까지 프로세스 A를 sleep 시킨다.(block 상태) child process 가 종료되면 커널은 프로세스 A를 깨운다. (ready 상태) exit() : free all the resources, notify parent 모든 자원을 반납하고 부모 프로세스에게 알림 자발적 종료 마지막 statement 수행 후 exit() 시스템 콜을 통해프로그램에 명시적으로 넣어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌 비자발적 종료 부모 프로세스가 자식 프로세스를 강제 종료시킴 자식 프로세스가 한계치를 넘어서는 자원요청 자식에게 할당된 태스크가 더이상 필요하지 않음 키보드로 kill, break (ex. ctrl+C) 등을 친 경우 부모가 종료하는 경우 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨 프로세스 간 협력 독립적 프로세스 (Independent process) 프로세스는 각자 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함 프로세스는 항상 독자적으로 행동한다. 프로세스 B가 프로세스 A의 메모리 참조하지 못한다. 협력 프로세스 (Cooperating process) 프로세스 간 협력 메커니즘 (IPC : Interprocess Communication) 메시지를 전달하는 방법 message passsing 주소 공간을 공유하는 방법 shared memory thread Message Passing IPC (Interprocess Communication) 원칙적으로 프로세스는 본인만의 code/data/stack 만 접근 가능 운영체제에게 시스템콜을 통해 부탁해서 메모리의 일부 공유하는 방법 프로세스끼리 서로 신뢰할 수 있다는 전제하에 shared memory 사용해야 한다. 하나의 프로세스의 일생 CPU burst : CPU 가 기계어를 실행 I/O burst : I/O 를 실행 프로세스는 그 특성에 따라 두 가지로 나눔 I/O bound process : CPU 를 잡고 계산하는 시간보다 I/O 에 많은 시간이 필요한 job CPU bound process : 계산 위주의 jop CPU scheduler &amp; Dispatcher 운영체제 코드의 일부 (SW) CPU Scheduler Ready 상태의 프로세스 중에서 이번에 CPU 를 줄 프로세스를 고른다. Dispatcher CPU 의 제어권을 CPU 스케줄러에 의해 선택된 프로세스에게 넘긴다. 이 과정을 context switch 라고 한다. CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다. Scheduling Crieteria (성능 척도) turnaround time CPU를 사용하는 시간 + CPU를 기다리는 시간 대기 시간 CPU 를 쓰러와서 기다린 전체시간 (기다린 시간의 합) 응답시간 프로세스가 CPU 를 쓰러 들어와서 최초로 얻게 되기까지 걸리는 시간 CPU burst 에 들어와서 최초로 CPU 를 얻게되기까지 Scheduling AlgorithmsFCFS (First-Come First-Served) convoy effect : 소요시간이 긴 프로세스가 먼저 도달하여 시간을 잡아먹고 있는 부정적인 현상 SJF (Shortest-Job-First) 각 프로세스의 다음번 CPU burst time 을 가지고 스케줄링에 활용 CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케줄 priority scheduling의 일종 두가지 방법 Nonpreemptive : 일단 CPU를 잡으면 이번 CPU burst가 완료될 때까지 CPU 를 선점당하지 않음 Preemptive : 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU 를 빼앗김 (=SRTF, Shortest-Remaining-Time-First) SJF is optimal 주어진 프로세스들에 대해 minimum everage waiting time 을 보장 SJF의 약점 starvation 발생 가능 (-&gt; 해결 방법 : aging) 참고 RR (Round Robin) 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가짐 (일반적으로 10-100msec) 할당 시간이 지나면 프로세스는 선점 (preempted) 당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다. n개의 프로세스가 ready queue 에 있고 할당 시간이 q time unit 인 경우 각 프로세스는 최대 q time unit 단위로 CPU 시간의 1/n 을 얻는다. 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다. Performance q large =&gt; FCFS q small =&gt; context switch 오버헤드가 커진다. SJF 보다 평균 소요시간 길지만 응답시간은 더 짧다. Multilevel Queue Ready queue 를 여러개로 분할 각 큐는 독립적인 스케줄링 알고리즘을 가짐 큐에 대한 스케줄링이 필요 starvation 발생 가능성 높음 -&gt; Time slice를 통해 각 큐에 CPU time을 적절한 비율로 할당 Multilevel Feedback Queue 프로세스가 다른 큐로 이동 가능 aging 을 이와 같은 방식으로 구현할 수 있다. ex) Multi-Processor Scheduling CPU 가 여러개인 경우 스케줄링은 더욱 복잡해진다. Real-Time Scheduling Hard real-time systems Hard real-time task 는 정해진 시간안에 반드시 끝내도록 스케줄링 해야함 Soft real-time systems Soft real-time task 는 일반 프로세스에 비해 높은 priority 를 갖도록 해야 함 Thread Scheduling Local Scheduling User level thread 의 경우 사용자 수준의 thread library 에 의해 어떤 thread 를 스케줄할지 결정 Global Scheduling Kernel level thread 의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 thread 를 스케줄할지 결정 Algorithm Evaluation어떤 CPU 스케줄링 알고리즘이 더 좋은지 평가하는 방법 Queueing models 확률 분포로 주어지는 arrival rate 와 service rate등을 통해 각종 performance index 값을 계산 아래 그림의 server 를 CPU 라고 보면 된다. Implementation (구현) &amp; Measurement (성능 측정) 실제 시스템에 알고리즘을 구현하여 실제 작업(workload)에 대해서 성능을 측정 비교 Simulation (모의 실험) 알고리즘을 모의 프로그램으로 작성 후 trace 를 입력으로 하여 결과 비교","link":"/2022/02/12/OS-04-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"},{"title":"OS&gt;03.프로세스 관리","text":"03. 프로세스 관리프로그램의 실행 프로그램은 파일 형태로 파일 시스템에 저장되어있다. 프로그램이 실행되면 메모리에 올라가서 프로세스가 된다. 그 중간 단계가 virtual memory 프로그램이 실행될 때 각각의 프로그램은 독자적인 address space 가 있다. 필요한 부분만 물리적인 메모리에 올라가게되고 그렇지 않은 부분은 swap area 에 올라간다. 메모리 주소 virtual memeory physical memory 이 두 메모리 주소 사이의 address translation 이 필요하다. address space (프로그램의 virtual memory) code : 실행 파일에 있는 기계어 code가 위치하는 부분 data : 전역 변수 stack : 지역 변수, 함수 호출 시 사용되는 객체들 kernel address space 도 code/data/stack 이 존재함 운영체제 data 영역에는 모든 하드웨어/프로세스를 관리하기 위한 자료구조를 가지고 있다. PCB(Process Control Block) : 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조 운영체제 stack kernel 의 stack 은 각 프로세스마다 별도로 두고 있다. 커널 함수 프로그램 실행파일 안에 들어있는 것이 아니라 커널(kernel code) 안에 들어있음 (=시스템 콜) 시스템콜 사용하기 위해 cpu 제어권을 프로세스에서 운영체제로 넘긴다. CPU옆에는 mode bit이라는 것이 붙어있다. mode bit 이 1 이면 user mode, 0이면 kernel mode 프로세스의 개념 프로세스 : 실행중인 프로그램 프로세스의 문맥(context) : 프로세스의 현재 상태 CPU 수행상태를 나타내는 하드웨어 문맥 Program Counter 각종 register 프로세스의 주소 공간 code, data, stack 프로세스 관련 커널 자료 구조 PCB Kernel stack 프로세스의 상태 프로세스는 상태(state) 가 변경되며 수행된다. Running : CPU 에서 실행중인 프로세스 CPU 를 잡고 instruction 을 수행중인 상태 Ready : 실행 대기 상태에 있는 프로세스 메모리 등 다른 조건을 만족하고 CPU 를 기다리는 상태 Blocked : Disk I/O 같은 오래 걸리는 작업때문에 당장 수행할 수 없는 상태 CPU 를 주어도 당장 instruction 을 수행할 수 없는 상태 Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태 New : 프로세스가 생성중인 상태 Terminated : 수행(execution) 이 끝난 상태 운영체제(kernel)가 data 영역의 PCB로 프로세스의 상태를 관리한다. 프로세스의 상태도 running 에서 상태 변하는 경우 Timer interrupt I/O or event wait exit Process Control Block(PCB) OS가 관리상 사용하는 정보 Process state, PID, … CPU 수행 관련 하드웨어 값 PC, registers 메모리 관련 code, data, stack 의 위치 정보 파일 관련 Open file descriptors Context Switch (문맥 교환) CPU 를 한 프로세스에서 다른 프로세스로 넘겨주는 과정 CPU 가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행 CPU 를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장 CPU 를 새롭게 얻는 프로세스의 상태를 PCB 에서 읽어옴 ❗ System call 이나 Interrupt 발생 시 반드시 context switch 가 일어나는 것은 아님 (1) A가 실행되다가 다시 A가 실행 : 문맥교환이 아님 (2) A가 실행되다가 B 가 실행됨 : 문맥교환 발생 (1)의 경우에도 CPU 수행 정보 등 context 의 일부를 PCB 에 save 해야하지만, Context switch 가 발생한 (2) 의 경우 그 부담이 훨씬 큼 ➕참고 프로세스 스케줄링 큐의 모습 스케줄러 (Scheduler) 운영체제에서 스케줄링을 하는 코드를 스케줄러라고 한다. (=코드의 일부) Long-term scheduler 프로세스 상태를 new에서 ready로 바꾸는 admitted 동작을 해준다. 우리가 다루는 일반적인 운영체제는 보통 장기 스케줄러가 없다. Medium-Term Scheduler 장기 스케줄러가 없는 대신 사용하는 스케줄러 프로세스에게서 memory 를 뺏는다. 프로세스의 상태 Blocked 와 Suspended 모두 CPU 를 얻지 못한다. Blocked : 요청한 event 끝나면 다시 ready 상태로 돌아감 Suspended : 일을 아예 못하고 있는 상태, 외부에서 resume 시켜줘야 상태 변화 가능 usermode 와 kernel mode의 running 상태 확인하기 프로세스 상태 변화도 위의 그림 기준으로 공부할 것 Thread Thread (=lightweight process) 프로세스의 CPU 수행 단위 CPU 수행 부분 (PC, register, Stack) 만 별도로 가지고 있고, 나머지는 공유 Thread 가 동료 Thread와 공유하는 부분 code data OS resources 전통적인 개념의 heavyweight process 는 하나의 thread 를 가지고 있는 task 로 볼 수 있다. single CPU 에서의 장점 Responsiveness : 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리를 할 수 있다. Resource Sharing : 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput) 과 성능향상을 얻을 수 있다. Economy : Context switch 보다 overhead 가 적다. multi CPU (multi processor) 에서의 장점 Utilization of Multi-Architectures : 스레드를 사용하면 병렬성을 높일 수 있다. thread 를 구현하는 방법에 따른 분류 Kernel Threads 운영체제가 thread 의 존재를 아는 경우 운영체제에서 thread 에게 직접 CPU 넘긴다. User Threads 운영체제가 thread 의 존재를 모르는 경우 사용자 프로그램에서 thread 를 관리 프로세스 생성 (Process Creation) 일반적으로 process 는 자원을 차지하기 위해 경쟁한다. 주소 공간 (Address space) 자식은 부모의 공간을 복사함 (binary and OS data) 자식은 그 공간에 새로운 프로그램을 올림 fork() 시스템 콜이 새로운 프로세스를 생성 부모를 그대로 복사 주소 공간 할당 fork() 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 fork 와 exec 의 차이점? 프로세스 종료 (Process Termination) fork() 부모 프로세스는 fork() 다음 코드를 실행하고, 복제된 자식프로세스는 부모와 똑같이 fork() 다음부터 실행한다. (Program counter 도 복제하기 때문) fork() 는 프로세스의 pid를 리턴한다. pid == 0 이면 자식프로세스 pid &gt; 0 이면 부모 프로세스 exec() Hello 를 출력하고 data 프로그램이 덮어 씌워진다. execpl 이후 코드는 실행되지 않는다. 부모 프로세스는 기존 코드 실행하고, 자식프로세스는 execpl 통해 date 프로그램 덮어 씌워진다.","link":"/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/"},{"title":"OS&gt;06.데드락","text":"07. 데드락 (Deadlocks) P0 는 A를 얻고 B를 기다림, P1는 B를 얻고 A를 기다림 프로세스가 자원을 사용하는 절차 요청 할당 사용 해제 Deadlock 발생의 4가지 조건 💡 운영체제 상식으로 자주 나오는 문제 다음 4가지 조건을 모두 만족해야 deadlock이 발생한다. 자원할당 그래프 프로세스와 자원의 관계를 그래프로 표현 R -&gt; P : 자원 R을 프로세스 P 가 점유하고 있다. P -&gt; R : 프로세스 P가 자원 R을 기다리고 있다. 그래프에 사이클이 없으면 deadlock 이 아니다. 그래프에 사이클이 있으면 자원이 1개밖에 없는 경우 deadlock 자원의 인스턴스가 여러개인 경우 deadlock이 아닐 수도 있다. Deadlock의 처리 방법 예방 Deadlock Prevention Deadlock Avoidance recover Deadlock Detection and recovery 아무것도 안함 Deadlock Ignorance Deadlock Prevention Deadlock Avoidance 프로세스들의 자원별 최대 사용량을 알고있다는 가정하에 사용되는 방법 safe sequence 가 존재한다. 가용자원 + 보유자원에 의해 프로세스의 모든 자원 요청을 처리할 수 있는 경우 자원이 하나의 인스턴스 가지고 있는 경우 Resource Allocation Graph algorithm 자원이 여러개의 인스턴스 가지고 있는 경우 Banker’s algorithm Resource Allocation Graph algorithm 실선 : 평생에 한번 이상 요청할 가능성 있음 점선 : 해당 자원을 요청함 점선을 포함해서 사이클이 만들어질 수 있는 가능성이 있기 때문에 P1 프로세스에게 자원을 주지 않음 언제까지? (P2가 자원을 반납해서) 더이상 사이클이 생기지 않을 때까지 Banker’s algorithm Allocation : 현재 할당된 자원 Max : 프로세스 별 최대 자원 사용량 (최대 요청량) Available : 아무도 쓰지않는 가용자원 Need : 최대 자원 사용량에서 현재 할당된 자원의 수를 뺀 것 12만약 P0이 C를 요청하면? P0의 C Need값은 3이고 C의 가용자원은 2이므로 자원을 주지 않는다.만약 P1이 A,B,C 요청하면? P1의 Need값이 1,2,2 이고 가용자원은 3,2,2이므로 자원을 할당한다. 항상 safe state를 유지 P1은 모든 Need 에 대한 자원 할당받아 일 끝내면 자원 반환 -&gt; available은 6,5,4가 된다. P3이 모든 Need 에 대한 자원 할당받아 일 끝냄.. …. P1, P3, P4, P2, P0 순서로 안전하게 자원 할당하여 프로세스 종료할 수 있는 시퀀스가 존재하면 시스템은 safe 하다고 할 수 있음 Deadlock Detection and recovery 데드락이 자주 생기는 상황이 아니므로 CPU 성능을 위해 여유자원이 있으면 무조건 준다. 데드락 발생은 허용하되 detection -&gt; recovery Detection 자원의 인스턴스가 한개인 경우 wait-for graph 사용 : 사이클이 존재하는지(deadlock detection) 더 쉽게 확인 가능 자원의 인스턴스가 여러 개인 경우 Banker’s algorithm 과 유사한 방법 활용 시퀀스가 존재 -&gt; 현재 데드락이 존재하지 않음 Recovery Process termination 데드락이 걸린 모든 프로세스 죽이는 방법 데드락이 걸린 프로세스를 하나씩 죽이는 방법 Resource Preemption 비용이 최소화되는 victim의 자원을 빼앗음 starvation 문제 비용과 rollback 횟수 같이 고려해야 함 Deadlock Ignorance","link":"/2022/02/19/OS-06-%EB%8D%B0%EB%93%9C%EB%9D%BD/"},{"title":"Network&gt;01.Roadmap","text":"컴퓨터 네트워크의 계층적인 프로토콜 구조를 이해한다. 인터넷에서 사용되고 있는 응용 프로그램, 트랜스포트 프로토콜, 라우팅 알고리즘과 프로토콜에 대하여 집중적으로 학습한다. 네트워크의 자원 활용율을 높이고 사용자에 대한 서비스를 향상시킬 수 있는 네트워크 프로토콜 설계 및 분석 능력을 배양한다. Computer network","link":"/2022/03/15/Network-01-Roadmap/"},{"title":"OS&gt;08.가상메모리","text":"","link":"/2022/02/26/OS-08-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"},{"title":"OS&gt;07.메모리 관리","text":"08. 메모리 관리Logical vs Physical address Logical address 가상 메모리 (=virtual address) Physical address 메모리의 물리적인 주소 Address Binding logical address 가 physical address로 바뀌는 시점이 언제인가? Compile time binding 컴파일 시 바인딩 됨 비효율적 (physical address 0번부터 시작하지 않으면 재컴파일 해야함) 현대 운영체제에서 적합하지 않음 Load time binding 프로그램 실행되는 시점에 바인딩 Run time binding 실행 시에 물리적인 주소 바인딩 되지만, 수행이 시작된 이후에도 메모리 위치를 옮길 수 있음 바인딩을 점검하는 과정 필요 하드웨어적인 지원 필요 (MMU) MMU 다음과 같은 주소변환 환경에서는 MMU 가 register 2개 필요하다. Relocation register Limit register 용어 설명Dynamic Loading 프로세스를 한꺼번에 메모리에 올리는 것이 아니라 해당 루틴이 불릴 때 올리는 것 운영체제의 지원 없이 프로그램에서 구현 가능, 현대의 운영체제에서도 메모리를 다 올리지 않고 필요한 부분만 올리지만 운영체제에서 지원한다는 차이가 있음 Overlays 필요한 부분만을 메모리에 올리는 것 Dynamic Loading 와 Overlays 비슷한 개념 overlay 는 초창기 시스템에서 프로세스의 크기가 메모리보다 클 때 사용되었던 방법 Swapping 프로세스를 일시적으로 메모리에서 backing store(=swap area)로 통째로 쫓아내는 것 Swap in : Suspended 상태가 됨 Swap out : Suspended 상태가 풀림 swaping 을 통해 메모리 공간을 효율적으로 사용하기 위해서는 run time binding 을 지원하는 하드웨어가 더 유리하다. swap time은 대부분 데이터가 transfer 되는데 걸리는 시간(transfer time)이다. 데이터의 양이 많기 때문 Dynamic Linking linking : 코드와 라이브러리 연결하는 작업 Dynamic linking linking 을 실행 시간까지 미루는 기법 라이브러리를 찾기 위한 위치정보(stub) 만 실행파일에 포함 shared library : dynamic linking을 하는 라이브러리 *.so : 리눅스 *.dll : 윈도우 Allocation of Physical Memory Contiquous allocation (연속 할당) 메모리의 연속적인 공간에 적재되는 것 💡 현대 운영체제는 사용하지 않고 있는 방법 고정 분할 방식 내부 조각 : 분할의 크기가 정해져있는데 프로그램의 크기가 더 작아서 자투리 공간이 낭비된다. 외부 조각 : 분할의 크기가 너무 작아서 사용되지 않는 부분이 생긴다. 가변 분할 방식 내부 조각으로 인해 낭비될 일이 없음 외부 조각은 여전히 발생 가능함 Hole Dynamic Storage-Allocation Problem 비어있는 hole 중 어느곳에 프로세스를 올릴것인지? First-fit / Best-fit / Worst-fit Compaction hole을 모아서 하나의 큰 block을 만드는 것 비용이 많이 듬 Noncontiguous allocation (불연속 할당) 하나의 프로세스가 메모리의 여러 영역에 분산되어 적재되는 것 Paging Segmentation Paged Segmentation Paging External fragmentation 발생 안함 : 연속 할당(가변 분할)은 프로그램의 크기가 제각각이라 hole이 생긴다. paging 기법은 메모리를 동일한 크기로 잘랐기 때문에 hole이 생기지 않는다. Internal fragmentation 발생 가능 : page 단위로 자르다보니 page보다 작아서 내부조각 생길 수 있다. page table을 사용하여 logical address 를 physical address로 변환 0번 엔트리, 1번 엔트리… 그림은 4개의 엔트리로 구성되어 있음 1번 프레임이 어느 프레임에 올라가있는지 알기 위해서는 page table 의 1번 엔트리를 보면 된다. -&gt; 4번 프레임 Page Table page table은 main memory 에 상주 PTBR 은 page table을 가리킴 PTLR 은 테이블 크기를 보관 TLB : 주소 변환을 빠르게 하기 위한 일종의 cache memory TLB TLB는 인덱스로 접근하는 것이 아니라 일부만 가지고 있기 때문에 TLB에서 정보를 찾기 위해서는 논리적인 page 번호와 물리적인 frame 번호를 모두 가지고 있어야 한다. page table은 page 위치만 알고있으면 page의 크기 알기 때문에 바로 프레임 찾을 수 있다. 각각의 프로세스마다 page table이 있다. context switch 할 때마다 TLB flush 된다. (overhead) Two-Level Page Table 주소를 주면, outer-page table, page table 를 거쳐서 메모리의 위치를 얻게된다. 시간적, 공간적으로 손해 같지만 그렇지 않다. why? outer-page table에서 사용안되는 주소값은 null 로 되어있어서 page table에서 아예 주소공간 만들어지지 않는다. p1, p2 = 10bit, 10bit d : page offset (12bit / 4K =2^12) 2단계 페이징 테이블에서도 outer-page 테이블의 시작위치는 PTBR이 가지고 있다. page table 의 시작위치는 outer-page table이 가지고 있다. Multilevel Paging and Performance valid bit in a Page Table frame 번호 뿐 아니라 bit가 하나 더 필요하다. v (valid) : 해당 페이지가 메모리에 올라가 있는 경우 i (invalid) : 해당 페이지가 메모리에 올라가 있지 않고 디스크에 내려가 있는 경우 해당 페이지를 사용하지 않거나, 해당 페이지가 물리적인 메모리에 올라가있지 않을때 Protection bit 페이지 테이블은 프로세스마다 있기 때문에 주소변환 하더라도 자신의 프로세스 주소만 접근 가능하다. protection bit는 접근 주체가 아니라 (프로세스는 어차피 접근 가능) read/write/read-only 가 가능한 페이지인지를 검사하는 bit code 의 경우 read-only : write를 못하게 막아줌 Inverted Page Table 원래 page table 은 논리 주소로부터 물리 주소값을 얻기 위해 사용되는 것 프로세스마다 page table이 존재하여 메모리의 낭비가 심함 이것을 보완하기 위해 물리적인 page frame 번호마다 page table이 존재 이것이 inverted page table inverted page table 물리적인 주소를 가지고 논리적인 주소를 알아내기 쉬운 구조 장점 : system-wide 하게 page table 하나만 있으면 된다. 단점 : 주소변환은 논리적인 주소를 물리적인 주소로 바꿔야하는데 inverted table은 물리적인 주소로부터 논리적인 주소값을 얻어내기 쉬운 구조로 되어있음. 주소를 변환하기 위해 page table을 모두 lookup 해야하는 overhead가 크다. 논리적인 페이지 번호 외에 어떤 프로세스의 페이지 번호인가를 나타내는 pid값을 추가로 저장해야 한다. Shared Page 동일한 프로그램이 프로세스 3개로 실행되었다고 가정했을 때 code 부분은 똑같고 data 부분만 다를 것 동일한 코드가 물리적 메모리에 여러번 올라가면 메모리 낭비 -&gt; shared code Shared code (= Re-entrant Code = Pure code) 의 제약조건 read-only 로 하여 프로세스 간에 하나의 code만 메모리에 올림 shared code 는 동일한 logical address 위치에 있어야 한다. Segmentation 프로그램을 의미 단위인 여러개의 segment로 구성 일반적으로 code, data, stack 으로 나뉨 s : segment number d : segment offset segment table 각각의 엔트리는 물리적 주소의 시작위치 뿐만 아니라 세그먼트의 길이 정보도 가지고 있다.(page는 모두 같은 크기로 나뉘어 있어 길이정보 필요없음) offset이 limit을 벗어나는 위치를 접근하려 하면 trap 을 건다. STBR : 메모리 상에 segment table이 어디있는지 시작위치를 가지고있음 STLR : segment table의 길이 (process가 몇개의 segment 로 구성되었는지) 프로그램이 사용하는 segment number s는 STLR보다 항상 작다. segment 길이가 다 제각각이기 때문에 외부조각 생길 수 있다. 단점 : external fragmentation 발생 가능 장점 : segmentation 은 의미단위이기 때문에 공유와 보안에 있어서 paging 보다 훨씬 효과적이다. Protection : Valid bit &amp; read/write/Execution 권한 bit paging은 크기단위로 잘랐기 때문에 page 마다 권한 설정 시 추가적인 제약조건이 필요할 수 있는데, segment 는 의미 단위이기 때문에 이런 문제 발생하지 않는다. Sharing : shared segment 같은 segment number 프로세스 별로 paging 기법의 경우 엔트리가 100만개, segment 는 n개이므로 메모리 관리 측면에서 장점이 있다. 💡 하지만 실제로 시스템에서는 paging 기법을 사용하고 있다. (pure segmentation 은 사용하지 않음) Segmentation with Paging segment table에서 해당 엔트리는 base address가 아닌 page table의 base address를 가지고 있음 segment table segment length : segment가 page 몇개로 구성되어 있는가 page-table base address","link":"/2022/02/23/OS-07-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/"},{"title":"OS&gt;05.병행제어","text":"05. 병행 제어데이터의 접근 Race Condition Race Condition(경쟁상태) : 하나의 공유 데이터에 동시에 접근하게 되었을 때 생기는 문제 서로 다른 프로세스들끼리는 CPU 갯수에 상관없이 race condition 문제되지 않는다. race condition은 CPU 가 하나여도 문제가 될 수 있다. ex) 하나의 프로세스가 시스템 콜을 하여 운영체제가 커널의 데이터를 사용하는 중 다른 사용자 프로세스에서 시스템 콜이 들어와 작업 중이던 커널의 데이터를 사용하는 과정에서 문제가 발생 OS에서 race condition 발생하는 경우 kernel 수행 중 인터럽트 발생 시 Process 가 system call 을 하여 kernel mode 로 수행 중인데 context switch가 일어나는 경우 Multiprocessor 에서 shared memory 내의 kernel data Process Synchronization 문제 공유데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제 (inconsistency)를 발생시킬 수 있다. 일관성(consistency)유지를 위해서는 협력 프로세스(cooperating process)간의 실행 순서(orderly execution)를 정해주는 매커니즘 필요 123💡 Race Condition* 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황* 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐 race condition 을 막기 위해서는 concurrent process 는 동기화(synchronize) 되어야 한다. race condition 의 예시 P1이 critical section 에 들어가면, P2는 critical section 에 들어가지 못하도록(lock) 막아야한다. 프로그램적 해결법의 충족 조건 Mutual Exclusion (상호 배제) Progress (진행) Bounded Waiting (유한대기) Algorithm 1 동시에 안들어가게 보장. 한 프로세스가 무한히 대기하는 문제 발생 Algorithm 2 두 프로세스가 계속 양보하는 상황 발생 Algorithm 3 (Peterson’s Algorithm) 임계영역 들어가기 전에 trun을 상대 차례로 설정, flag과 turn 둘 다 검사 문제점 : Busy Waiting (=spin lock) 내가 critical section 에 못들어가는 상황. while문 돌면서 계속 CPU 와 memory 를 낭비함 123456💡 정리turn : 공유자원을 사용하고 싶다고 표현하기 위한 변수flag : 누구의 차례인지 명시해주는 변수1. turn 만 사용2. flag 만 사용3. turn 과 flag 둘 다 사용 Synchronization hardware race condition 생기는 이유는 CPU 에서 메모리 읽어와서 값 변경하여 저장하는 과정이 atomic하게 이루어지지 않아서이다. hardware에서 atomic 하게 수행할 수 있다면 race condition 문제 발생하지 않는다. atomic : 중단되거나 분할될 수 없는 원자적 명령어 Semaphores 일종의 추상 자료형 P(S) : s를 감소, 공유데이터를 획득하는 과정 V(s) : s를 증가, 공유데이터를 반납하는 과정 busy waiting (=spin lock) 에는 효율적이지 못함 -&gt; Block &amp; Wakeup (=sleep lock) 방식의 구현 mutex(mutual exclusion) : 하나만 critical section에 들어갈 수 있다 Block/Wakeup Implementation P(S) 연산 후 S.value 가 음수이면 block(sleep) 상태 (= P 연산 불가능하면 프로세스 자체를 잠들게 함) V(S) 연산을 통해 S.value가 양수가 되어야만 임계영역 들어갈 수 있다. 일반적으로 Block/Wakeup 이 훨씬 좋다. Critical section 의 길이가 길면 Block/Wakeup 이 적당 Critical section 의 길이가 매우 짧으면 busy-wait 가 더 효과적일 수도 있다. Critical section 경쟁이 치열하면 -&gt; Block/Wakeup Semaphores 의 타입 Counting semaphore 도메인이 0 이상인 임의의 정수값 주로 resource counting 에 사용 Binary semaphore (=mutex) 0 또는 1 값만 가질수 있는 세마포어 주로 mutual exclusion (lock/unlock) 에 사용 Deadlock and Starvation Deadlock P0 이 S 획득, P1이 Q를 획득 P0 이 Q 획득하려고 보니까 P1이 가지고있음. P1이 S 획득하려고 보니까 P0가 가지고있음 (=Starvation) 각 프로세스 입장에서 보면 Starvation 상태 해결방법? P0과 P1이 둘다 S 먼저 획득하도록 P1의 순서 바꾸면 Deadlock 발생하지 않는다. Classial Problems of SynchronizationBounded-Buffer Problem Produser process 생산자 프로세스는 데이터를 만들어서 공유버퍼에 집어넣는 역할 Consumer process 소비자 프로세스는 데이터를 꺼내가는 역할 해결 방법 공유 버퍼에 lock 을 걸고 푸는 동작이 필요 counting semaphore를 이용하여 남은 버퍼의 갯수를 세고, binary semaphore를 이용하여 공유버퍼의 lock 을 걸고 푸는 동작을 한다. Producer 빈 버퍼를 얻고 락을 걸고 버퍼에 추가하고 락을 푼다. 내용이 들어있는 버퍼 반환 Consumer 내용이 들어있는 버퍼 획득 락을 걸고 버퍼에 내용을 꺼내가고 락을 푼다. 빈 버퍼를 반환 Readers-Writers Problem 읽기 쓰기는 주로 DB쪽에서 많이 하기 때문에 공유데이터의 예시를 DB로 들었음 readcount 가 양수인경우 : 다른 reader가 접근 중 readcount 가 0인 경우 : 다른 reader가 접근하지 않고있음 readcount 라는 변수도 동시접근을 막기위해 lock을 사용함 -&gt; mutex writer는 db에 접근하기 위해 db에 lock을 건다. reader는 db를 읽기 위해 readcount에 대한 mutex lock을 걸고 readcount를 증가시키고 mutex lock을 풀어준다. if readcount == 1 : 최초 접근하는 reader는 db에 lock 을 걸어서 writer의 접근을 막아야 한다. 1이 아닌 경우는 현재 db를 읽고있는 reader가 있으므로 굳이 db에 lock을 걸 필요 없이 db에 접근하면 된다. reader는 db를 다 읽으면 readcount를 감소시킨다. 동일하게 전후에 mutex lock 을 걸고/해제한다. if readcount == 0 : 마지막 reader는 db에 lock을 풀어서 writer가 접근이 가능하도록 해야한다. starvation 발생 가능 (이론적) reader 100개가 도착해서 db lock 을 걸고 db를 읽고있다. writer는 db를 접근하기 위해 대기 중 마지막 reader가 읽고 나가려는 때에 reader 1000개가 도착함 writer는 무한정 기다림 해결 방법 일정 시간 간격을 두고 그 이내에 도착한 reader들만 동시접근을 허용한다. Dining-Philosophers Problem 문제점 : 다섯명의 철학자가 모두 왼쪽 젓가락을 잡으면 아무도 밥을 먹지 못한다. -&gt; deadlock 젓가락을 두개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 하자 self[i] == 1 : 양 쪽 젓가락을 모두 잡을 수 있는 상태 (default 0) mutex : 공유 데이터에 대한 lock/unlock state : 편의상 상태 체크 pickup(i) : i라는 철학자가 젓가락을 듦 상태를 hungry 로 바꾸고, test(i) : 젓가락을 모두 잡을 수 있는 상태인지 테스트한다. 양쪽 젓가락을 모두 잡을 수 있으면 state를 eating 으로 바꾸고 V연산을 통해 self[i] 를 1로 만들어준다. V연산을 통해 젓가락 잡을 수 있는 권한 1을 얻고, P 연산을 통해 self 를 -1 하고 젓가락을 잡게된다. 만약 양쪽 젓가락을 잡을 수 없어서 V연산을 하지 못하면, P 연산 하려고 할때 self[i] 의 상태가 0이 되므로 block 상태(잠든 상태)가 된다. eat() : 먹는다. putdown(i) : 젓가락을 내려놓는다. state 를 thinking으로 바꾸고 내 왼쪽 철학자와 오른쪽 철학자에 대해 test를 수행한다. (젓가락 잡을 권한 획득) 1💡 일반적인 semaphore의 쓰임이 아니므로 동작에 대한 이해만 하고 넘어갈 것 Monitors 공유 데이터를 접근하기 위해서 monitor 안에 정의된 함수를 이용하여 접근할 수 있도록 하는 것 공유 데이터에 대한 동시접근을 모니터가 책임져주는 것 (semaphore는 책임져주지 않음) 공유 데이터를 모니터 안에 정의하고, 공유 데이터를 접근하는 코드는 모니터 안의 연산으로만 접근할 수 있게함 프로세스가 공유데이터 접근하기 위해서는 모니터의 코드 사용 여러 프로세스가 접근하는 경우, entry queue를 통해 진입 자체를 막아 동기화 문제를 해결 condition variable : 자원의 여분이 있을 때만 수행, 그렇지 않은경우 blocked blocked queue의 역할 (queue에 줄세우기) Bounded-Buffer Problem (Monitor) buffer[N] : Monitor 안의 공유데이터 모니터는 lock을 걸거나 푸는 코드가 없음 (프로그래머 입장에서 편리) produce() 빈 버퍼가 있으면 add data 빈 버퍼가 없으면 empty.wait() -&gt; 다른 프로세스가 모니터에서 활성화 될 수 있게 함 full.signal() 을 통해 내용이 있다는 시그널을 보냄 consume() 버퍼가 없는 경우 full.wait() 내용이 든 버퍼를 하나 꺼내서 빈 버퍼가 생기게 함 empty.signal() 을 통해 빈 버퍼를 기다리는 produce를 깨움 1💡 세마포어는 원자적으로 세마포어에 대한 +1,-1연산을 지원, 모니터는 아예 동시접근을 막아주는 역할을 한다는 차이가 있음 Dining Philosophers (Monitor) 젓가락을 잡는 코드가 모니터 안의 코드로만 실행되도록 함 self[5] : 젓가락을 잡을 수 있는지? pickup(i) 상태를 hungry 로 바꾸고 젓가락 두개를 다 잡을 수 있는지 테스트 테스트가 끝나서 젓가락을 잡았으면 (state==eating) 먹으면 된다. -&gt; eat() 못먹으면 self[i].wait() - queue에 줄서서 blocked test(i) 젓가락을 잡을 수 있으면 상태를 eating으로 바꾸고 (잠들어 있을 수 있는) 철학자를 깨워주기 위해 self[i].signal() putdown(i) 상태를 thinking 으로 바꾸고 인접 철학자들에 대해 test 를 수행한다. -&gt; 인접 철학자를 깨움 교착상태 (Deadlock) P0 는 A를 얻고 B를 기다림, P1는 B를 얻고 A를 기다림 프로세스가 자원을 사용하는 절차 요청 할당 사용 해제 💡 운영체제 상식으로 자주 나오는 문제 : Deadlock의 발생 4가지 조건 다음 4가지 조건을 모두 만족해야 deadlock이 발생한다. 자원할당 그래프 프로세스와 자원의 관계를 그래프로 표현 R -&gt; P : 자원 R을 프로세스 P 가 점유하고 있다. P -&gt; R : 프로세스 P가 자원 R을 기다리고 있다. 그래프에 사이클이 없으면 deadlock 이 아니다. 그래프에 사이클이 있으면 자원이 1개밖에 없는 경우 deadlock 자원의 인스턴스가 여러개인 경우 deadlock이 아닐 수도 있다. Deadlock의 처리 방법 예방 Deadlock Prevention Deadlock Avoidance recover Deadlock Detection and recovery 아무것도 안함 Deadlock Ignorance Deadlock Prevention Deadlock Avoidance","link":"/2022/02/16/OS-05-%EB%B3%91%ED%96%89%EC%A0%9C%EC%96%B4/"},{"title":"WEB&gt;그리드 시스템&#x2F;반응형 웹","text":"그리드 시스템/반응형 웹CSS12💡선택자 연습용 사이트https://flukeout.github.io/ CSS LayoutCSS 원칙 Ⅰ(Normal Flow)💡 모든 요소는 네모(박스모델)이고, 위에서부터 아래로, 왼쪽에서 오른쪽으로 쌓인다. float 💡박스를 왼쪽 혹은 오른쪽으로 이동시켜 텍스트를 포함 인라인 요소들이 주변을 wrapping 하도록 함 💡요소가 Normal Flow 를 벗어나도록 함 float 속성 none : 기본값 left : 요소를 왼쪽으로 띄움 right : 요소를 오른쪽으로 띄움 Clearing Float float 요소의 부모를 div 를 감싸준다. 부모에게 clearfix class 적용 12345.clearfix::after { content: &quot;&quot;; display: block; clear: both;} Float 는 Normal Flow 에서 벗어나 부동 상태 (떠 있음) 따라서, 이후 요소에 대하여 Float 속성이 적용되지 않도록 Clearing 이 필수적임 ::after : 선택한 요소의 맨 마지막 자식으로 가상요소를 하나 생성 보통 content 속성과 함께 짝지어, 요소에 장식용 콘텐츠를 추가할 때 사용 clear 속성 부여 float 는 block 레이아웃의 사용을 뜻하기 때문에 inline 요소에 적용하게 되면 block 요소로 바뀌어 적용된다. ✍️ Float 활용 전략 - Normal Flow 에서 벗어난 레이아웃 구성 - 원하는 요소들을 float 로 지정하여 배치 - 부모 요소에 반드시 clearing float 를 하여 이후 요소부터 normal flow 를 가지도록 규정 flexbox 💡💡💡 행과 열 형태로 아이템을 배치하는 1차원 레이아웃 모델 축 main axis cross axis 💡 flex-direction : row (기본값) Flexbox 구성 요소💡 Flew Container (부모 요소) flexbox 레이아웃을 형성하는 가장 기본적인 모델 Flex Item 들이 놓여있는 영역 💡display 속성을 flex 혹은 inline-flex 로 지정 123.flex-container { display: flex;} Flex Item (자식 요소) 컨테이너에 속해 있는 컨텐츠 💡자손영역에는 영향을 미치지 않고 오직 나의 자식 영역에만 영향을 미친다. Q. 왜 Flexbox 를 사용해야 할까? float 혹은 position 을 통해서는 1. 수직 정렬 1. 아이템의 너비와 높이 혹은 간격을 동일하게 배치 하는 것이 어렵다. flex 속성💡💡💡[배치 설정] flex-direction main axis 기준 방향 설정 flex-wrap 아이템이 컨테이너를 벗어나는 경우 해당 영역 내에 배치되도록 설정 nowarp(기본 값) : 한 줄에 배치 wrap : 넘치면 그 다음줄로 배치 flex-flow 💡💡💡 flex-direction과 flex-wrap의 shorthand flex-flow: row wrap; [공간 나누기] 💡justify-content : Main axis 를 기준으로 공간 배분 flex-start (기본 값) : 아이템을 axis 시작점으로 flex-end : 아이템들을 axis 끝 쪽으로 center : 아이템들을 axis 중앙으로 space-between : 아이템 사이의 간격을 균일하게 분배 space-around : 아이템을 둘러싼 영역을 균일하게 분배 (가질 수 있는 영역을 반으로 나눠서 양쪽에) space-evenly : 전체 영역에서 아이템 간 간격을 균일하게 분배 align-content : Cross axis 를 기준으로 공간 배분 [정렬] 💡align-items : 모든 아이템을 Cross axis 를 기준으로 정렬 💡stretch (기본 값) : 컨테이너를 가득 채움 flex-start : 위 flex-end : 아래 center : 가운데 💡baseline : 텍스트 baseline 에 기준선을 맞춤 align-self : 개별 아이템을 Cross axis 를 기준으로 정렬 (컨테이너가 아닌 개별 아이템에 적용하는 속성) [기타 속성] 💡flex-grow : 남은 영역을 아이템에 분배 💡order : 배치 순서 기본값은 0 숫자가 클 수록 우선순위는 낮다. 12💡Flexbox Froggy (https://flexboxfroggy.com/#ko)* flexbox 연습용 사이트 flex-shrink flex-basis gridbootstrap 웹사이트를 쉽게 만들 수 있게 도와주는 HTML, CSS, JS 프레임워크 하나의 CSS 로 휴대폰, 태블릿, 데스크탑까지 다양한 기기에서 작동한다. 사용법 더 편한 사용법 : CDN (Content Delivery Network) 컨텐츠 (CSS, JS, Image, Text 등)을 효율적으로 전달하기 위해 여러 노드에 가진 네트워크에 데이터를 제공하는 시스템 https://www.bootstrapcdn.com/ 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; spacing 💡💡💡 bootstrap grid system 💡💡💡💡Grid System (web design) 요소들의 디자인과 배치에 도움을 주는 시스템 기본 요소 Column : 실제 컨텐츠를 포함하는 부분 Gutter : 칼럼과 칼럼 사이의 공간 (사이 간격) Container : Column 들을 담고 있는 공간 Bootstrap Grid System 은 flexbox 로 제작됨 12💡 12개의 column💡 6개의 grid breakpoints (xs, sm, md, lg, xl, xxl)💡 💡(Container), rows, columns 으로 컨텐츠를 배치하고 정렬 container는 좌우 공간 확보용일 뿐이다. (가독성을 위함, 필수요소는 아님) 💡반드시 row를 부모 요소로 넣어준 후 col class 설정해야 grid가 나뉘어진다. (부모) class=row (자식) class=col-{숫자} (참고)","link":"/2022/02/07/WEB-%EA%B7%B8%EB%A6%AC%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/"},{"title":"OS&gt;09.파일시스템","text":"파일 시스템File and File System File File attribute (metadata) 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들 File system 운영체제에서 파일을 관리하는 부분 파일,파일의 메타데이터를 저장하고 관리 Directory and Logical Disk Partition 운영체제가 보는 논리적인 디스크 여러개의 물리적인 디스크를 하나의 파티션으로 합칠수도 있음 open() open() : 파일의 메타데이터를 메모리에 올리는 것 open() 을 통해 root의 메타데이터로부터 b의 메타데이터까지 읽어온다. open이 완료되면 b의 fd값을 통해 read함수를 실행시켜 b의 content를 읽어서 메모리에 올린다. File Protection Access Control 방법에는 세가지가 있다. Access control matrix Grouping (일반적으로 사용하는 방법) 전체 user 를 owner, group, public 의 세그룹으로 구분 각 파일에 대해 세 그룹의 접근권한 (rwx)을 3비트씩 표시 Password File System의 Mounting Access Methods Allocation of File Data in Disk디스크에 파일 저장할때는 동일한 크기의 섹터단위로 저장하고 있다. 따라서 임의의 크기의 파일을 동일한 크기의 block 단위로 나누어 저장하고 있다. Contiguous Allocation 연속할당 : 하나의 파일을 연속된 block에 저장하는 방법 단점 외부조각 발생 가능 파일의 크기를 키우는데 제약이 있다. 장점 빠른 I/O : Readitme file 또는 process 의 swapping 용도로 사용하기 좋다. Linked Allocation 파일의 데이터를 디스크에 연속적으로 할당하지 않고 링크를 통해 연결하는 방법 파일의 실행위치만 디렉토리가 가지고있고, 다음 실행 위치는 직접 가서 데이터를 읽어봐야 알 수 있음 순차 접근만 가능해진다. Indexed Allocation 디렉토리에 인덱스 블럭의 정보만 가지고 있는 방식 UNIX 파일 시스템의 구조 Boot block 어떤 파일 시스템이던 boot block 이 맨 앞에 있다. Super block 파일 시스템에 관한 총체적인 정보 Inode 파일 이름을 제외한 파일의 메타데이터 실제 운영체제에서는 디렉토리가 파일의 모든 정보 가지고 있지 않고, 일부만 가지고 나머지는 Inode에 저장 파일의 이름은 디렉토리 파일이 가지고 있다. Data block 파일의 실제 내용 보관 FAT File System File-allocation table System Free-Space Management 비어있는 블록을 관리하는 방법 Bit map or bit vector bit map 은 디스크의 부가적인 공간을 필요로 함 연속적인 빈 block 을 찾는데 효과적 Linked list 모든 free block 들을 링크로 연결, 연속적인 가용 공간을 찾는것이 쉽지 않다. Grouping linked list방법의 변형 마지막 포인터가 가리키는 block 이 또 다시 n pointer를 가지는 방법 Counting 프로그램들이 종종 여러개의 연속적인 block을 할당하고 반납한다는 성질에 착안 Directory Implementation Linear list file name, metadata 의 리스트로 저장 디렉토리 내에 파일이 있는지 찾기 위해서 linear search 필요 Hash Table linear list + hashing search time을 없앰 VFS and NFS Virtual File System (VFS) 서로 다른 파일 시스템에 상관 없이 동일한 시스템 콜 인터페이스를 통해 접근할 수 있게 해주는 OS의 layer Network File System (NFS) 서로 다른 컴퓨터가 네트워크로 연결되어 있을 때, 원격으로 다른 컴퓨터에 있는 파일 시스템을 접근할 수 있도록 해주는 분산 파일 시스템 Page Cache and Buffer Cache Memory-mapped I/O 파일의 일부를 virtual memory 에 mapping 시킴 -&gt; 파일을 읽거나 쓰는 접근이 아니고 메모리 공간에 접근하는 것이 됨 Unified Buffer Cache (현대의 UNIX) memory-mapped I/O 시 전통적인 File I/O 보다 한단계가 줄어들었다. (참고) 프로그램의 실행","link":"/2022/03/02/OS-09-%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"},{"title":"WEB","text":"WEB (HTML &amp; CSS) 여러가지의 태그들이 각각의 웹 브라우저에서 지원되는지 알려주는 사이트 https://caniuse.com/ 초록색 = 지원함 빨간색 = 지원하지 않음 노란색 = 부분적으로 지원함 회색 = 지원여부를 아직 모름 HTML Hyper Text Markup Language Hyper Text : 참조(하이퍼링크)를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트 Markup Language : 태그 등을 이용하여 문서나 데이터의 구조를 명시하는 언어 ex) HTML, Markdown HTML 기본 구조 &lt;!DOCTYPE html&gt; : 해당 문서가 html5 로 구성되어 있음 (생략 가능), 구버전 브라우저(IE) 사용하는 경우 호환성을 위해 명시하는 것이 좋음 html : 문서의 최상위 요소 head : 문서 메타 데이터 요소 💡 head 와 header 헷갈리지 않기 문서 제목, 인코딩, 스타일, 외부 파일 로딩 등 일반적으로 브라우저에 나타나지 않는 내용 &lt;title&gt; : 브라우저 상단 타이틀 &lt;meta&gt; : 문서 레벨 메타데이터 요소 &lt;link&gt; : 외부 리소스 연결 요소 (CSS, favicon) &lt;script&gt; : 스크립트 요소 (JavaScript 파일/코드), body 에도 들어갈 수 있음 &lt;style&gt; : CSS 직접 작성 Open Graph Protocol 메타 데이터를 표현하는 새로운 규약 body : 문서 본문 요소 실제 화면 구성과 관련된 내용 DOM(Document Object Model) 트리 텍스트 파일인 HTML 문서를 브라우저에서 렌더링하기 위한 구조 HTML 문서에 대한 모델을 구성함 HTML 문서 내의 각 요소에 접근/수정에 필요한 프로퍼티와 메서드를 제공함 요소 (element) : 태그 + 내용 요소 (element) HTML 요소는 시작 태그와 종료 태그, 그리고 태그 사이에 위치한 내용으로 구성 내용이 없는 태그들 br, hr, img, input, link, meta 요소는 중첩(nested) 될 수 있음 💡부모 요소와 자식 요소 요소의 중첩을 통해 하나의 문서를 구조화 여는 태그와 닫는 태그의 쌍을 잘 확인해야 함 오류를 반환하는 것이 아닌 그냥 레이아웃이 깨진 상태로 출력되기 때문에 디버깅이 힘들어 질 수 있음 속성 (attribute) 속성을 통해 태그의 부가적인 정보를 설정할 수 있음 요소는 속성을 가질 수 있으며, 경로나 크기와 같은 추가적인 정보를 제공 요소의 시작태그에 작성하며 보통 💡이름과 값이 하나의 쌍으로 존재 태그와 상관없이 사용 가능한 속성(HTML Global Attribute)들도 있음 MDN web docs 사용법 검색 시 사용 HTML Global Attribute💡 모든 HTML 요소가 사용할 수 있는 대표적인 속성 (몇몇 요소에는 아무 효과가 없을 수 있음) id : 문서 전체에서 유일한 고유 식별자 지정 class : 공백으로 구분된 해당 요소의 클래스 목록 (CSS, JS 에서 요소를 선택하거나 접근) data-* : 페이지에 개인 사용자 정의 데이터를 저장하기 위해 사용 style : inline 스타일 title : 요소에 대한 추가 정보 지정 tabindex : 요소의 탭 순서 시맨틱 태그💡💡💡 HTML5 에서 의미론적 요소를 담은 태그의 등장 기존 영역을 의미하는 div 태그를 대체하여 사용 Non Semantic 요소는 div, span등이 있으며 h1, table 태그들도 시맨틱 태그로 볼 수 있음 개발자 및 사용자 뿐만 아니라 검색엔진 등에 의미있는 정보의 그룹을 태그로 표현 단순히 구역을 나누는 것 뿐만 아니라 ‘의미’를 가지는 태그들을 활용하기 위한 노력 💡요소의 의미가 명확해지기 때문에 코드의 가독성을 높이고 유지보수를 쉽게 함 검색엔진최적화(SEO)를 위해서 매타태그, 시맨틱 태그 등을 통한 마크업을 효과적으로 활용 해야함 header : 문서 전체나 섹션의 헤더 (머리말 부분) nav : 내비게이션 aside : 사이드에 위치한 공간, 메인 콘텐츠와 관련성이 적은 콘텐츠 section : 문서의 일반적인 구분, 컨텐츠의 그룹을 표현 article : 문서, 페이지, 사이트 안에서 독립적으로 구분되는 영역 footer : 문서 전체나 섹션의 푸터(마지막 부분) HTML 문서 구조화인라인/블록 요소텍스트 요소💡💡💡 💡&lt;strong&gt;, &lt;em&gt;: ‘강조’의 의미를 가지는 시맨틱 태그 그룹 컨텐츠 table💡💡💡 💡 대신 가 들어갈 수도 있다. (의미론적) theader, tbody, tfoot 요소를 활용하여 table 의 각 영역을 명시 &lt;tr&gt; 로 가로줄을 구성하고 내부에는 &lt;th&gt; 혹은 &lt;td&gt; 로 셀을 구성 12345678910111213141516171819202122232425262728&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Major&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;홍길동&lt;/td&gt; &lt;td&gt;Computer Science&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;김철수&lt;/td&gt; &lt;td&gt;Business&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;총계&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;2명&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;caption&gt;1반 학생 명단&lt;/caption&gt;&lt;/table&gt; form 💡💡💡 💡**&lt;form&gt;은 정보(데이터)를 서버에 제출하기 위한 영역** 123456&lt;form action=&quot;&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;아이디&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; autofocus&gt; &lt;/div&gt;&lt;/form&gt; 기본 속성 action : form 을 처리할 서버의 URL method : form 을 제출할 때 사용할 HTTP 메서드 (GET 혹은 POST) enctype : method 가 post 인 경우 데이터의 유형 application/x-www-form-urlencoded : 기본값 multipart/form-data : 파일 전송 시 (input type 이 file인 경우) text/plain : HTML5 디버깅 용 (잘 사용되지 않음) input 💡다양한 입력을 가지는 입력 데이터 유형과 위젯이 제공되는 태그는? 다양한 입력을 가지는 입력 데이터 유형과 위젯이 제공됨 name : form control 에 적용되는 이름 (이름/값 페어로 전송됨) value : form control 에 적용되는 값 (이름/값 페어로 전송됨) required, readonly, autofocus, autocomplete, disabled : 단일 속성(속성 값 없이 속성 명만 있어도 동작함) 💡&lt;input type=&quot;submit&quot;&gt; 사용할 수 있는 type 에는 text, password, email, number, file, checkbod, radio 등등이 있음 💡input label label을 클릭하여 input 자체의 초점을 맞추거나 활성화 시킬 수 있음 사용자는 선택할 수 있는 영역이 늘어나 웹/모바일(터치) 환경에서 편하게 사용할 수 있음 label 과 input 입력의 관계가 시각적 뿐만 아니라 화면 리더기에서도 label 을 읽어 쉽게 내용을 확인할 수 있도록 함 💡&lt;input&gt;에 id 속성을, &lt;label&gt;에는 for 속성을 활용하여 상호 연관을 시킴 12&lt;label for=&quot;agreement&quot;&gt;개인 정보 수집에 동의합니다.&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;agreement&quot; id=&quot;agreement&quot;&gt; CSS 💡CSS (Cascading Style Sheets) : 스타일을 지정하기 위한 언어 세미콜론 필수 CSS 구문은 선택자를 통해 스타일을 지정할 HTML 요소를 선택 중괄호 안에서는 속성과 값, 하나의 쌍으로 이루어진 선언을 진행 각 쌍은 선택한 요소의 속성, 속성에 부여할 값을 의미. 속성 (Property) : 어떤 스타일 기능을 변경할지 결정 값 (Value) : 어떻게 스타일 기능을 변경할지 결정 CSS 정의 방법 💡💡💡 인라인 (inline) 해당 태그에 직접 style 속성을 활용 내부 참조 (embedding) - &lt;style&gt; &lt;head&gt; 태그 내에 &lt;style&gt; 에 지정 외부 참조 (link file) - 분리된 CSS 파일 외부 CSS 파일을 &lt;head&gt;내 &lt;link&gt; 를 통해 불러오기 재사용성 높음 CSS 우선순위 - 순서와도 영향이 있음(가장 마지막에 선언된 것이 적용됨) CSS Selectors 💡💡💡💡💡 기본 선택자 💡 전체 선택자, 요소 선택자 클래스 선택자(.), 아이디 선택자(#), (속성 선택자) 결합자 (Combinators) 💡 자손 결합자( ), 자식 결합자(&gt;) 일반 형제 결합자, 인접 형제 결합자 의사 클래스/요소 (Pseudo Class) 링크, 동적 의사 클래스 구조적 의사 클래스, 기타 의사 클래스, 의사 엘리먼트, 속성 선택자 123456789💡CSS 선택자 정리* 요소 선택자 * HTML태그를 직접 선택* 클래스 선택자 * 마침표 (.) 문자로 시작하며, 해당 클래스가 적용된 항목을 선택* 아이디 선택자 * `#` 문자로 시작하며, 해당 아이디가 적용된 항목을 선택 * 일반적으로 하나의 문서에 1번만 사용. 여러번 사용해도 동작하지만, 단일 id를 사용하는 것을 권장 CSS 적용 우선순위 (cascading order) 💡💡💡💡💡 중요도(Important) !important 우선순위 인라인 &gt; id &gt; class, 속성, pseudo-class &gt; 요소, pseudo-element &gt; 전체 선택자 CSS 파일 로딩 순서 가장 마지막이 우선순위가 높다. CSS 상속 💡💡💡 CSS는 상속을 통해 부모 요소의 속성을 자식에게 상속한다. 속성중에는 상속이 되는 것과 되지 않는 것들이 있다. 상속 되는 것 예시 Text 관련 요소 (font, color, text-align), opacity, visibility 등 상속되지 않는 것 예시 Box model 관련 요소 (width, height, margin, padding, border, box-sizing, display), posision 관련 요소 (position, top/right/bottom/left, z-index) 등 CSS 기본 스타일 크기 단위 px(픽셀) 모니터 해상도의 한 화소인 ‘픽셀’기준 픽셀의 크기는 변하지 않기 때문에 고정적인 단위 % 백분율 단위 가변적인 레이아웃에서 자주 사용 ex) 부모요소의 width 의 60% 💡 em (바로 위 부모 요소에 대한) 상속의 영향을 받음 ex) 1.5em -&gt; 부모 요소의 1.5배 💡rem 최상위 요소(html) 의 사이즈를 기준으로 배수 단위를 가짐 💡viewport 웹페이지를 방문한 유저에게 바로 보이게 되는 웹 컨텐츠 영역 디바이스의 viewport 를 기준으로 상대적인 사이즈가 결정됨 💡 viewport 단위 : vw, vj, vmin, vmax 를 기준으로 상대적인 단위 결정 색상 단위 💡 색상 키워드 rgb(10진수,10진수,10진수), rgba hsl, hsla a는 투명도 Selectors 심화 💡💡💡💡💡 자손 결합자 💡💡 selector A 하위의 모든 selector B 요소 띄어쓰기로 자손을 표현 li p 자식 결합자 💡💡 selector A 바로 아래의 selector B 요소 li &gt; p 일반 형제 결합자💡 selector A 의 형제 요소 중 뒤에 위치하는 selector B 요소를 모두 선택 p ~ span 인접 형제 결합자💡 selector A 의 형제 요소 중 바로 뒤에 위치하는 selector B 요소를 선택 p + span CSS Box model 💡💡💡 모든 요소는 네모(박스모델)이고, 💡위에서부터 아래로, 왼쪽에서 오른쪽으로 쌓인다. 모든 HTML 요소는 box 형태로 되어있음 하나의 박스는 네 영역으로 이루어짐 💡content / padding / border / margin 💡띄어쓰기로 구분, 두개 쓰면 상하 좌우, 세개일때는 상 중 하, 네개일때는 상 우 하 좌 shorthand Border box-sizing 💡💡💡12345💡 기본적으로 모든 html의 박스모델은 content-box가 기본 설정, padding 제외한 순수 contents 영역만을 box로 지정div { box-sizing : border-box;} content-box : default 💡💡💡border-box : (우리가 일반적으로 영역 볼 때 원하는 너비) border까지의 영역을 설정 CSS Display 💡💡💡 모든 요소는 네모(박스모델) 이고, 좌측 상단에 배치, display에 따라 크기와 배치가 달라진다. display : block 💡 줄바꿈이 일어나는 요소 화면 크기 전체의 가로 폭을 차지한다. 블록 레벨 요소 안에 인라인 레벨 요소가 들어갈 수 있음 div / ul, ol, li / p / hr / form등 display : inline 💡 줄 바꿈이 일어나지 않는 행의 일부 요소 content 너비만큼 가로 폭을 차지한다. width, height, margin-top, margin-bottom 을 지정할 수 없다. 상하 여백은 line-height 로 지정한다. span / a / img / input, label / b, em, i, strong 등 display : inline-block 💡 block 과 inline 레벨 요소의 특징을 모두 가짐 inline 처럼 한 줄에 표시 가능하고, block 처럼 width, height, margin 속성을 모두 지정할 수 있음 display : none 💡💡 해당 요소를 화면에 표시하지 않고, 공간조차 부여되지 않음 visibility : hidden 과의 차이점💡💡 해당 요소가 공간은 차지하나 화면에 표시만 하지 않는다. CSS Position 💡💡💡 문서 상에서 요소를 위치를 지정 static : 모든 태그의 기본 값(기준 위치) 일반적인 요소의 배치 순서에 따름 (normal flow) 💡부모 요소 내에서 배치될 때는 부모요소의 위치를 기준으로 배치 됨 아래는 좌표 프로퍼티(top, bottom, left, right)를 사용하여 이동 가능 💡💡💡relative 와 absolute 차이 중요 (relative absolute fixed) relative 상대위치 내 자리 유지 💡자기 자신의 static 위치를 기준으로 이동, 나머지 요소들은 normal flow 유지 레이아웃에서 요소가 차지하는 공간은 static 일 때와 같음 absolute 절대 위치 내 자리 X 요소를 normal flow 에서 제거 후 레이아웃에 공간을 차지하지 않음 💡normal flow에서 벗어남 💡static이 아닌 💡가장 가까이 있는 부모/조상 요소를 기준으로 이동 (없는 경우 body) fixed 고정 위치 내 자리 X 요소를 normal flow 에서 제거 후 레이아웃에 공간을 차지하지 않음 부모 요소와 관계없이 💡viewport 를 기준으로 이동 (스크롤 시에도 항상 같은 곳에 위치함) CSS 원칙 정리 참고emmethttps://docs.emmet.io/cheat-sheet/ HTML &amp; CSS 를 작성할 때 보다 빠른 마크업을 위해 사용되는 오픈소스 단축키, 약어 등을 사용 대부분의 텍스트 에디터에서 지원","link":"/2022/02/03/WEB/"},{"title":"algo&gt;BOJ_14890(경사로,골드3)","text":"https://www.acmicpc.net/problem/14890 오르막 경사로가 필요한 경우, 내리막 경사로가 필요한 경우, 높이차이가 2 이상이라 경사로를 놓지 못하는 경우로 나누어 풀었다. Top-down 방식으로 위에서부터 구현 완료하고 넘어가야 구현과 디버깅이 쉽다. check 함수에서 최대한 필요없는 변수를 안쓰려고 노력했는데 코드 가독성을 위해 리팩토링이 필요할 것 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&quot;&quot;&quot;BOJ경사로골드31시간 20분https://www.acmicpc.net/problem/14890&quot;&quot;&quot;def check(road): go = True visited = [True] * len(road) # 경사로를 놓았는지 기록할 배열 for i in range(1, len(road)): diff = abs(road[i-1] - road[i]) if diff &gt; 1: # 높이 차이가 1이 아닌 경우 go = False break elif diff == 1: # 높이 차이가 1인 경우 if road[i-1] &lt; road[i]: # 오르막일때 cnt = 0 for j in range(i-L,i): if j &gt;= 0 and road[j] == road[i-1] and visited[j]: visited[j] = False cnt += 1 if cnt == L: continue elif road[i-1] &gt; road[i]: # 내리막일 때 cnt = 0 for j in range(i, i+L): if j &lt; N and road[j] == road[i] and visited[j]: visited[j] = False cnt += 1 if cnt == L: continue # if~elif 를 통해 continue 로 통과되지 않는 경우 go = False break return goN, L = map(int, input().split())arr = [list(map(int, input().split())) for _ in range(N)]res = 0# 지나갈 수 있는 길인지 한 줄씩 검색 (가로)for i in range(N): if check(arr[i]): # print(arr[i]) res += 1# 전치행렬을 통해 다시 검색 (세로)arr_trans = list(map(list,zip(*arr)))for i in range(N): if check(arr_trans[i]): # print('-',arr_trans[i]) res += 1print(res)","link":"/2022/03/23/algo-BOJ-14890-%EA%B2%BD%EC%82%AC%EB%A1%9C-%EA%B3%A8%EB%93%9C3/"},{"title":"OS&gt;10.입출력시스템","text":"10. 입출력 시스템Disk Scheduling cylinder : 하드디스크를 구성하고 있는 모든 원판 상에 위치하고 있는 단일 트랙 위치(같은 트랙번호를 갖는 각 면에 있는 트랙들의 집합) Disk Structure logical block : 디스크 외부에서 보는 디스크의 단위 정보 저장 공간들 sector : 하드 드라이브의 최소 기억 단위 디스크 내부에서는 디스크 컨트롤러가 원판, 트랙, 섹터번호 알려줘야 데이터 찾을 수 있다. 디스크 외부에서는 logical block 번호 이용하여 데이터를 찾는다. Disk Management physical formatting : 디스크 컨트롤러가 디스크를 섹터 단위로 나누는 과정 디스크를 만들고 처음으로 하는 과정 섹터는 header + (실제)data + trailer 로 구성 header/trailer : 컨트롤러가 디스크를 관리하기 위한 정보 partitioning : 디스크를 논리적인 디스크로 나누는 과정 C드라이브, D드라이브… Logical formatting : 파티셔닝한 논리적 디스크에 파일 시스템을 설치하는 것 Booting ROM : 전원을 꺼도 데이터가 사라지지 않는 메모리 small bootstrap loader 를 실행 (-&gt; 디스크의 0번 sector를 load해라) Disk Scheduling Access time Seek time : 헤드를 해당 실린더로 움직이는데 걸리는 시간 Rotational latency : 헤드와 섹터가 만나기까지 걸리는 회전지연시간, seek time 의 1/10 정도 걸림 Transfer : 실제 데이터의 전송시간, seektime에 비해 굉장히 작은 시간 디스크를 효율적으로 관리하려면 헤드의 이동 거리를 줄이는 것이 중요 Disk bandwidth (대역폭) : 단위 시간당 전송된 바이트의 수 bandwidth 를 높이기 위해 disk scheduling을 잘해야한다. Disk Scheduling : seek time을 최소화 하는것이 목표 Disk Scheduling Algorithm 큐에 다음과 같은 실린더 위치의 요청이 존재하는 경우 디스크 헤드 53번에서 시작한 각 알고리즘의 수행 결과는 ? (실린더 위치는 0-199) 98, 183, 37, 122, 14, 124, 65, 67 FCFS (First Come First Served) 선착순 처리 헤드의 이동 상당히 빈번 SSTF (Shortest Seek Time First) 현재 위치부터 seek time이 가장 작은 요청부터 우선 처리 head의 이동거리는 짧아질 수 있지만 starvation 의 문제가 있다. SCAN⭐ disk scheduling 에서 가장 핵심적인 방법 head가 한쪽 끝에서 다른쪽 끝으로 이동하며 처리할 수 있는 모든 요청을 처리하고 지나간다. C-SCAN 디스크 헤드가 한쪽 끝에 도달하면 바로 출발점으로 다시 이동 Other Algorithms Look : 가려는 방향에 더이상 요청없으면 바로 턴 디스크 스케줄링 알고리즘은 OS 와 별도의 모듈로 작성되어야 한다. Swap-space Management Swap-space 전원을 끄면 사라질 정보들이기 때문에 공간 효율성보다는 속도 효율성이 우선 헤드의 이동 줄이기 위해 큰 단위로 데이터를 읽고 쓴다. RAID 신뢰성 향상 데이터를 서로 다른 디스크에 중복 저장 완전 중복 저장을 하면 공간 낭비가 심하므로 최소한의 중복을 통해 신뢰성을 높일 수도 있다. parity : 일종의 축약된 정보 UNIX 파일 시스템 파일 시스템 구성 : super block + i-node block + data block i-node block 하나에는 i-node 여러개가 들어간다. (참고. 파일시스템의 변천사) Ext2 파일 시스템 데이터를 15개의 포인터 블록으로 구성 12 Direct ptr : 직접 데이터를 가리킴 3 Indirect ptr : 큰 file 표현 시 사용 블록의 그룹화 각각의 그룹에 메타 데이터와 실제 데이터를 같이 배치 -&gt; 디스크 헤드의 이동시간 줄임 수퍼블록을 그룹마다 중복 저장하여 디스크 오류(배드 섹터)에 대비 inode table / data block : 실제 아이노드와 데이터가 저장되는 위치 Ext2와 Ext4의 구조는 거의 동일 Ext4는 여러 플랫폼에서 사용되고 있다. 저널링?? 저널링 (Journaling) 전원이 나가면 버퍼캐시 내용이 휘발된다. 재부팅하면 파일시스템에는 Inconsistent data만 남는다. (깨진 데이터) journaling 수정된 내용을 주기적으로 저널영역에 기록 Ext4의 저널링 메타데이터 저널링 모드 체크 포인팅 주기가 오면 journal area의 메타데이터를 파일 시스템에 반영한다. 메타데이터에는 파일 시스템의 구조정보(위치정보)가 있다. 메타데이터를 저널링하면 파일 시스템 자체가 깨어지는 것 방지할 수 있지만, 일반 데이터는 깨질 수 있는 가능성이 존재한다. 데이터 저널링 모드 파일 시스템뿐 아니라 데이터도 깨지지 않는다. 버퍼캐시 교체 알고리즘 LRU 단점 : 자주 사용되는 블록에 대한 고려 X LFU 단점 : 사용횟수만 고려하고 최근 사용된 블록에 대한 고려 X LRFU 알고리즘 각각의 block 에 대해 value를 계산하고 그 값이 가장 작은 블록을 버퍼캐시에서 삭제 LFU 적 성질 : 사용 횟소가 많으면 value 가 커지게 된다. LRU 적 성질 : 최근 사용된 블록일 수록 value 의 증가에 더 큰 기여 실효성 Space overhead Time overhead 아무리 시간이 흐르더라도 시간정보 t 만으로 계산이 가능하다. 모든 block 정보 가지고있을 필요 없어서 space overhead 해결 가능 블럭들이 재사용되지 않는 이상 value의 대소관계 변하지 않는다. Heap 을 이용하여 구현 지금은 LRFU 보다 성능 좋은 알고리즘도 많다. LRFU : LRU 와 LFU 의 단점 보완하면서 효율적으로 구현할 수 있는 알고리즘","link":"/2022/03/06/OS-10-%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%8B%9C%EC%8A%A4%ED%85%9C/"},{"title":"git branch","text":"Branch Git에서 Branch라는 개념은 매우 중요합니다. 사실상 버전 관리의 꽃이라고 할 수 있습니다. https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell 나뭇가지처럼 여러 갈래로 작업 공간을 나누어 독립적으로 작업할 수 있도록 도와주는 Git의 도구 개발을 하다 보면 코드를 여러 개로 복사해야 하는 일이 자주 생기는데, 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있도록 도움 장점 독립 공간을 형성하기 때문에 원본(master)에 대해 안전 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적인 개발이 가능 특히나 Git의 브랜치는 매우 가벼우며 순식간에 브랜치를 새로 만들고 브랜치 사이를 이동할 수 있음 브랜치를 꼭 써야할까? 일단 master 브랜치는 상용을 의미합니다. 그래서 언제든 세상에 공개되어 있습니다. 만약 상용에 에러가 있어서 고쳐야 한다면 어떻게 해야할까요? 고객들이 사용하고 있는데, 함부로 버전을 되돌리거나 삭제할 수 있을까요? 따라서 브랜치를 통해 별도의 작업 공간을 만들고, 그곳에서 되돌리거나 삭제를 합니다. 브랜치는 완전하게 독립이 되어있어서 어떤 작업을 해도 master에는 영향을 끼치지 못하죠. 그리고 이후에 에러를 해결했다면? 그 내용을 master에 반영할 수도 있습니다! 이러한 이유 때문에 Git에서 브랜치는 정말 강력한 기능 중의 하나라고 할 수 있습니다. Branch commandgit branch 브랜치 조회, 생성, 삭제 등 브랜치와 관련된 Git 명령어 123456789101112# 브랜치 목록 확인$ git branch# 원격 저장소의 브랜치 목록 확인$ git branch -r# 새로운 브랜치 생성$ git branch &lt;브랜치 이름&gt;# 특정 브랜치 삭제$ git branch -d &lt;브랜치 이름&gt; # 병합된 브랜치만 삭제 가능$ git branch -D &lt;브랜치 이름&gt; # (주의) 강제 삭제 (병합되지 않은 브랜치도 삭제 가능) git switch “Switch branches” 현재 브랜치에서 다른 브랜치로 HEAD를 이동시키는 명령어 HEAD란 현재 브랜치를 가리키는 포인터를 의미합니다. 2019년 8월 git 2.23 버전에서 출시 https://git-scm.com/docs/git-switch https://github.blog/2019-08-16-highlights-from-git-2-23/ 12345# 다른 브랜치로 이동$ git switch &lt;다른 브랜치 이름&gt;# 브랜치를 새로 생성과 동시에 이동$ git switch -c &lt;브랜치 이름&gt; git switch 주의사항 “git switch 하기 전에, 워킹 디렉토리 파일이 모두 버전 관리가 되고 있나요? master 브랜치와 feature 브랜치가 있다고 가정해보자 feature 브랜치에서 test.txt를 만들고 git add 하지 않은 상태에서git switch master를 하면 어떤 일이 발생할까? 바로 feature 브랜치에서 만들었던 test.txt가 master 브랜치에도 똑같이 생성됨 “왜 그럴까?” Git의 브랜치는 독립적인 작업 공간을 가지지만, 어디까지나 Git이 관리하는 파일 트리에 한해서임 git add를 하지 않은, 즉 Staging Area에 한 번도 올라가지 않은 새 파일은Git의 버전 관리를 받고 있지 않기 때문에 브랜치가 바뀌더라도 계속 유지되는 것 따라서 반드시 git switch를 하기 전에는 모든 워킹 디렉토리의 파일이 버전 관리가 되고 있는지 확인해야 함 Branch scenario git branch와 git switch를 통해 브랜치를 조회, 생성, 이동하는 실습을 진행 (1) 사전 세팅 홈 디렉토리에 git-branch-practice 폴더를 생성하고 이동 후 vscode를 엽니다. 123$ mkdir git-branch-practice$ cd git-branch-practice$ code . Git 저장소를 생성합니다. 12$ git initInitialized empty Git repository in C:/Users/kyle/git-branch-practice/.git/ test.txt를 생성하고 각각 master-1, master-2, master-3 이라는 내용을 순서대로 입력하여 커밋 3개를 작성합니다. 12345678910111213$ touch test.txt# test.txt에 master-1 작성$ git add .$ git commit -m &quot;master-1&quot;# test.txt에 master-2 작성$ git add .$ git commit -m &quot;master-2&quot;# test.txt에 master-3 작성$ git add .$ git commit -m &quot;master-3&quot; git log --oneline을 입력했을 때 아래와 같이 나와야 정상입니다.총 3개의 버전이 master 브랜치에 만들어졌습니다. 1234$ git log --oneline0604dcd (HEAD -&gt; master) master-39c22c89 master-23d71510 master-1 현재 모습 (2) 브랜치 생성 및 조회 현재 위치(master 브랜치의 최신 커밋)에서 login이라는 이름으로 브랜치를 생성합니다. 1$ git branch login login브랜치가 잘 생성되었는지 확인합니다.* master의 의미는 현재 HEAD가 가리키는 브랜치는 master라는 것입니다. 123$ git branch login* master git log --oneline을 입력했을 때 아래와 같이 나와야 정상입니다.0604dcd 커밋 기준으로 master와 login브랜치가 위치한 것을 볼 수 있습니다. 1234$ git log --oneline0604dcd (HEAD -&gt; master, login) master-39c22c89 master-23d71510 master-1 master 브랜치에서 1개의 커밋을 더 작성합니다. 123# test.txt에 master-4 작성$ git add .$ git commit -m &quot;master-4&quot; 현재 브랜치와 커밋의 상태 확인 12345$ git log --oneline5ca7701 (HEAD -&gt; master) master-40604dcd (login) master-39c22c89 master-23d71510 master-1 현재까지 결과 (3) 브랜치 이동 현재 브랜치와 커밋의 상태는 다음과 같습니다. 12345$ git log --oneline5ca7701 (HEAD -&gt; master) master-40604dcd (login) master-39c22c89 master-23d71510 master-1 이때 login브랜치로 이동하면 어떤 일이 일어날까요? 1$ git switch login master 브랜치의 test.txt에 작성한 master-4가 지워졌습니다! 12345# login 브랜치의 test.txt 모습master-1master-2master-3 그리고 git log --oneline을 입력하면 아래와 같이 나타납니다.이제 HEAD는 login 브랜치를 가리키고, master 브랜치가 보이지 않습니다. 1234$ git log --oneline0604dcd (HEAD -&gt; login) master-39c22c89 master-23d71510 master-1 master 브랜치는 삭제된 걸까요?아닙니다! 브랜치를 조회 해보면 다음과 같이 나타납니다.HEAD가 login 브랜치를 가리키면서, log도 login 브랜치 기준으로 보이는 것이었습니다. 123$ git branch* login master git log --oneline --all을 입력하면 모든 브랜치의 로그를 볼 수 있습니다. 12345$ git log --oneline --all5ca7701 (master) master-40604dcd (HEAD -&gt; login) master-39c22c89 master-23d71510 master-1 현재까지 결과 즉, 브랜치를 이동한다는건 HEAD가 해당 브랜치를 가리킨다는 것을 의미하고, 브랜치는 최신 커밋을 가리키므로, HEAD가 해당 브랜치의 최신 커밋을 가리키게 됩니다. 따라서 워킹 디렉토리의 내용도 HEAD가 가리키는 브랜치의 최신 커밋 상태로 변화합니다. (4) login 브랜치에서 커밋 생성 test.txt 파일에 login-1이라고 작성합니다. 12345# login 브랜치의 test.txtmaster-1master-2master-3login-1 추가적으로 test_login.txt도 생성하고 login-1이라고 작성해봅시다. 1234$ touch test_login.txt# 이후 test_login.txt에 작성login-1 커밋을 생성합니다. 12$ git add .$ git commit -m &quot;login-1&quot; git log --oneline --all --graph를 통해 아래와 같은 내용을 확인합니다.master 브랜치와 login 브랜치가 다른 갈래로 갈라진 것을 확인할 수 있습니다. 1234567$ git log --oneline --graph --all* 3b0a091 (HEAD -&gt; login) login-1| * 5ca7701 (master) master-4|/* 0604dcd master-3* 9c22c89 master-2* 3d71510 master-1 현재까지 결과 Branch Merge 이제 각 브랜치에서의 작업이 끝나면 어떻게 할까요?그 작업 내용을 master에 반영해야 하지 않을까요?지금부터는 Merge라고 하는 병합을 학습하면서 브랜치를 합치는 것을 살펴보자. git merge 분기된 브랜치들을 하나로 합치는 명령어 git merge &lt;합칠 브랜치 이름&gt;의 형태로 사용합니다. Merge하기 전에 일단 다른 브랜치를 합치려고 하는, 즉 메인 브랜치로 switch 해야합니다. 1234567891011# 1. 현재 branch1과 branch2가 있고, HEAD가 가리키는 곳은 branch1 입니다.$ git branch* branch1 branch2# 2. branch2를 branch1에 합치려면?$ git merge branch2# 3. branch1을 branch2에 합치려면?$ git switch branch2$ git merge branch1 Merge의 세 종류1. Fast-Forward 브랜치를 병합할 때 마치 빨리감기처럼 브랜치가 가리키는 커밋을 앞으로 이동시키는 것 현재 master는 C2 커밋을, hotfix는 C4 커밋을 가리키고 있습니다. master에 hotfix를 병합하면 어떻게 될까요? 123456$ git switch master$ git merge hotfixUpdating s1d5f1s..1325sd4Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) hotfix가 가리키는 C4는 C2에 기반한 커밋이므로, master가 C4에 이동하게 됩니다.이렇게 따로 merge 과정 없이 브랜치의 포인터가 이동하는 것을 Fast-Forward라고 합니다. 병합이 완료된 hotfix는 더 이상 필요 없으므로 삭제합니다. 12$ git branch -d hotfixDeleted branch hotfix (1325sd4). 2. 3-Way Merge (Merge commit) 브랜치를 병합할 때 각 브랜치의 커밋 두개와 공통 조상 하나를 사용하여 병합하는 것 두 브랜치에서 다른 파일 혹은 같은 파일의 다른 부분을 수정했을 때 가능합니다. 현재 master는 C4 커밋을, iss53은 C5 커밋을 가리키고 있습니다.master와 iss53의 공통 조상은 C2 커밋입니다. 이 상황에서 master에 iss53을 병합하면 어떻게 될까요? 123456$ git switch masterSwitched to branch 'master'$ git merge iss53Merge made by the 'ort' strategy.index.html | 1 +1 file changed, 1 insertion(+) master와 iss53은 갈래가 나누어져 있기 때문에 Fast-Forward로 합쳐질 수 없습니다.따라서 공통 조상인 C2와 각자가 가리키는 커밋인 C4, C5를 비교하여 3-way merge를 진행합니다. 이때 생긴 C6는 master와 iss53이 병합되면서 발생한 Merge Commit입니다. 병합이 완료된 iss53은 더 이상 필요 없으므로 삭제합니다. 12$ git branch -d iss53Deleted branch iss53 (58sdf23). 3. Merge Conflict 병합하는 두 브랜치에서 같은 파일의 같은 부분을 수정한 경우, Git이 어느 브랜치의 내용으로 작성해야 하는지 판단하지 못해 발생하는 충돌(Conflict) 현상 결국은 사용자가 직접 내용을 선택해서 Conflict를 해결해야 합니다. 현재 master는 C4 커밋을, iss53은 C5 커밋을 가리키고 있습니다.master와 iss53의 공통 조상은 C2 커밋입니다. (3-way merge에서의 상황과 같습니다) 3-way merge와는 달리, 만약 master와 iss53이 같은 파일의 같은 부분을 수정하고 병합한다면 어떤 일이 발생할까요? 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 충돌이 일어난 파일을 확인하기 위해 git status를 입력합니다. 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) index.html을 열어보면 아래와 같이 충돌 내역이 나옵니다. 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html ======= 를 기준으로 위는 master의 내용, 아래는 iss53의 내용입니다.이 중 하나를 선택할 수도 있고, 둘 다 선택할 수도 있고, 아예 새롭게 작성할 수도 있습니다. 123&lt;div id=&quot;footer&quot;&gt;please contact us at email.support@github.com&lt;/div&gt; 이후 git add와 git commit을 통해 병합한 내용을 커밋할 수 있습니다. 12$ git add .$ git commit Vim 편집기가 켜지며 이를 이용해서 커밋 내역을 수정할 수 있습니다.(수정을 마치거나 수정할 것이 더이상 없을 경우 esc 를 누른후:wq 를 입력하여 저장 &amp; 종료) 12345678910111213141516171819Merge branch 'iss53'Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: index.html# Branch Merge scenario사전 세팅 123456789101112$ mkdir git_merge$ cd git_merge$ git init$ touch test.txt# test.txt 에 master test 1 을 입력 후 저장$ git status$ git add .$ git commit -m &quot;master test 1&quot; 3가지 병합 상황1. fast-forward “login 브랜치가 생성된 이후 master 브랜치에 변경 사항이 없는 상황” 즉, master 브랜치에서 login 브랜치를 Merge 할 때login 브랜치가 master 브랜치 이후의 커밋을 가리키고 있으면그저 master 브랜치가 login 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐 login branch 생성 및 이동 1$ git switch -c login 특정 작업 완료 후 commit 123$ touch login.txt$ git add .$ git commit -m &quot;login test 1&quot; master 브랜치로 이동 12345$ git switch master$ git log --oneline --all --graph* df231d0 (login) login test 1* 1e62b4c (HEAD -&gt; master) master test 1 master 에 병합 login을 병합 1234567$ git merge loginUpdating 43fab3e..2fe539cFast-forward login.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 login.txt 결과 확인 (fast-foward, 단순히 HEAD를 앞으로 빨리감기) 123$ git log --oneline --all --graph* 2fe539c (HEAD -&gt; master, login) login test 1* 43fab3e master test 1 login 브랜치를 삭제 123456$ git branch -d loginDeleted branch login (was df231d0).$ git log --oneline --all --graph* 2fe539c (HEAD -&gt; master) login test 1* 43fab3e master test 1 2. 3-way Merge (Merge commit) 현재 브랜치(master)가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니면,git 은 각 브랜치가 가리키는 커밋 2 개와 공통조상 하나를 사용하며 3-way Merge 한다. 단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge 의 결과를별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다.그래서 이런 커밋은 부모가 여러 개고 Merge commit 이라고 부른다. signout 브랜치 생성 및 이동 1$ git switch -c signout 특정 작업 완료 후 commit 123456789101112$ touch signout.txt$ git add .$ git commit -m &quot;signout test 1&quot;[signout d9f33e2] signout test 1 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 signout.txt$ git log --oneline --all --graph* d9f33e2 (HEAD -&gt; signout) signout test 1* 2fe539c (master) login test 1* 43fab3e master test 1 master 브랜치로 이동 1$ git switch master master 에 추가 작업 후 commit (단, signout 브랜치와 다른 파일을 생성 혹은 수정) 1234567891011$ touch master.txt$ git add .$ git commit -m &quot;master test 2&quot;$ git log --oneline --all --graph* 07fae72 (HEAD -&gt; master) master test 2| * d9f33e2 (signout) signout test 1|/* 2fe539c login test 1* 43fab3e master test 1 master에 signout을 병합 (자동 merge commit 발생) 12345$ git merge signoutMerge made by the 'recursive' strategy. signout.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 signout.txt log 확인 12345678$ git log --oneline --all --graph* 1170a02 (HEAD -&gt; master) Merge branch 'signout'|\\ | * d9f33e2 (signout) signout test 1* | 07fae72 master test 2|/ * 2fe539c login test 1* 43fab3e master test 1 signout 브랜치 삭제 12$ git branch -d signoutDeleted branch signout (was d9f33e2). 3. Merge Conflict Merge 하는 두 브랜치에서 같은 파일의 같은 부분을 동시에 수정하고 Merge 하면Git은 해당 부분을 자동으로 Merge 하지 못하고 충돌이 일어남(반면 동일 파일이더라도 서로 다른 부분을 수정했다면, Conflict 없이 자동으로 Merge Commit 된다.) hotfix 브랜치 생성 및 이동 1$ git switch -c hotfix 특정 작업 완료 후 commit 1234# test.txt 수정master test 1이건 hotfix 에서 작성한 문장이에요!! 123456789101112131415$ git add .$ git commit -m &quot;hotfix test 1&quot;[hotfix e6cf5ec] hotfix test 1 1 file changed, 2 insertions(+)$ git log --graph --oneline --all* e6cf5ec (HEAD -&gt; hotfix) hotfix test 1* 1170a02 (master) Merge branch 'signout'|\\| * d9f33e2 signout test 1* | 07fae72 master test 2|/* 2fe539c login test 1* 43fab3e master test 1 master 브랜치로 이동 1$ git switch master 특정 작업(hotfix 와 동일 파일의 동일 부분 수정) 완료 후 commit 1234# text.txt 수정master test 1이건 master 에서 작성한 코드에용ㅎㅎ!! 1234567891011121314$ git add .$ git commit -m &quot;master test 3&quot;$ git log --oneline --all --graph* 1bc2eeb (HEAD -&gt; master) master test 3| * e6cf5ec (hotfix) hotfix test 1|/* 1170a02 Merge branch 'signout'|\\| * d9f33e2 signout test 1* | 07fae72 master test 2|/* 2fe539c login test 1* 43fab3e master test 1 master에 hotfix를 병합 1$ git merge hotfix 결과 → merge conflict 발생 (같은 파일의 같은 문장을 수정했기 때문) 충돌 확인 및 해결 Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면git status 명령을 이용한다. 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 123456master test 1&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD이건 master 에서 작성한코드에용ㅎㅎ!!=======이건 hotfix 에서 작성한문장이에요!!&gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix ======= 위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용이고 아래쪽은 hotfix 브랜치의 내용이다.충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 해야 한다.(&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt; 가 포함된 행을 삭제) 1234# test.txt 최종본master test 1충돌을 해결해보자!! merge commit 진행 12$ git add .$ git commit VIM 에디터 등장 자동으로 작성된 커밋 메세지(Merge branch 'hotfix')를 확인하고esc 를 누른후:wq 를 입력하여 저장 &amp; 종료 1[master eec8da4] Merge branch 'hotfix' log 확인 12345678910111213$ git log --oneline --all --graph* eec8da4 (HEAD -&gt; master) Merge branch 'hotfix'|\\ | * e6cf5ec (hotfix) hotfix test 1* | 1bc2eeb master test 3|/ * 1170a02 Merge branch 'signout'|\\ | * d9f33e2 signout test 1* | 07fae72 master test 2|/* 2fe539c login test 1* 43fab3e master test 1 hotfix 브랜치를 삭제 12$ git branch -d hotfixDeleted branch hotfix (was e6cf5ec).","link":"/2022/03/11/git-branch/"},{"title":"Git &amp; Github","text":"Why Git &amp; Github?1. Git을 이용한 버전 관리 git : (분산) 버전 관리 프로그램 버전 : 컴퓨터 소프트웨어의 특정 상태 관리 : 어떤 일의 사무, 시설이나 물건의 유지/개량 프로그램 : 컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 모음 중앙 집중식 버전 관리 분산 버전 관리 2. Github 를 이용한 포트폴리오 TIL Git git 은 분산버전관리시스템(DVCS) Distributed Control System 소스코드의 버전을 관리하고 이력도 관리할 수 있다. 준비하기 윈도우에 git 을 설치한다. (git bash 설치) 초기 설치 완료 후 로컬 컴퓨터에 Author 정보를 설정해야한다. 1234$ git config --global user.email 유저이메일$ git config --global user.name 유저네임$ git config --global -l // 설정값을 확인하는 명령어 1. 저장소 초기화123$ git init~/TIL (master) // master 명 확인으로 git 관리여부 확인 Working Directory Staging Area Local Repository (commit) 실제 작업되는 공간변경점이 나타나면 이곳에 파일이 등록 commit 되기 전 임시로 파일들이 보여지는 곳이곳에서 commit 되어도 되는지 파일을 확인 git 으로 관리되는 파일들의 버전들이 저장되는 곳 2. 상태 확인1$ git status // WD, SA 상태를 확인하기 위한 명령어 Untracked git 으로 관리되지 않았던 파일이 등록된 경우 WD에서 해당 단어를 확인할 수 있음 Tracked New file : git 으로 관리되지 않았던 파일이 Staging Area 에 등록되었을 때 확인할 수 있음 modified : git 으로 관리되는데 수정된 파일이 Staging Area 에 등록되었을 때 확인할 수 있음 4. gitignore 프로젝트와 관련 없는 파일을 등록하여 commit 되지 않도록 하는 것 민감한 개인 파일이나 개인 컴퓨터 설정파일 (OS에서 활용되는 파일) IDE 환경 설정 파일 (.idea/) 가상환경 폴더 및 파일 .gitignore 파일을 생성 제외하고 싶은 파일을 등록 파일명을 적어주면 끝 gitignore.io 를 이용하면 편하게 .gitignore 파일을 작성할 수 있음 단, 우리가 생성한 파일은 우리가 직접 등록해야함 (ex. 단순 참고 용도인 파일들) 5. Commit 을 위한 준비12$ git add 파일명$ git add . // 현재 폴더 내에 있는 변경/추가된 파일 모두를 등록 Working Directory 에서 Staging Area 로 관리 파일들을 이동시키는 명령어 Staging Area 에서 관리 대상에 대한 판단을 하고 commit 여부를 결정 6. Commit 하기1$ git commit -m &quot;커밋 메세지를 남기자! 유의미한 내용으로 작성&quot; 버전 이력을 확정짓는 명령어 해당 시점의 파일 변경된 내용을 스냅샷으로 기록해 남긴다. 7. Commit 이력 확인하기1234$ git log$ git log --oneline // 한 줄로 축약해서 보여줌$ git log -p // 파일의 변경 내용도 같이 보여줌$ git log -숫자 // 숫자만큼만 보여줌 원격 저장소 (remote repository) github/gitlab 1. 원격 저장소 등록 사용을 하기 위해서는 로컬에 원격 저장소의 url 주소를 등록해야 함 1$ git remote add 저장소별명(origin) 저장소주소 등록된 원격 저장소의 주소를 확인하는 방법 1$ git remote -v 저장소 삭제 1$ git remote rm 저장소별명 2. 원격 저장소에 commit 내용 보내기 로컬에 저장된 commit 을 원격 저장소로 전달하여 분산 버전 관리를 완성하는 부분 12$ git push 저장소별명 브랜치명$ git push -u origin master -u : -set-upstream 의 shortcut 형태이고 저장소 별명과 브랜치 명을 설정 3. 원격 저장소에서 내려받기1. git clone git init, git remote add 동작이 포함된 내려받기 명령어 아무것도 없는 상태일 때 사용 git clone 리모트레포주소 2. git pull remote 서버의 정보를 내려받는 명령어 git 이 적용되어 있어야 한다. (.git 폴더가 존재해야함) remote 정보가 등록되어 있어야 한다. git pull 리모트별명 브랜치명 기타)submodule warning 메세지를 봤다!!! 어떤 폴더가 submodule 인지 확인한다. 해당 폴더로 찾아가서 .git 폴더를 제거한다. 이미 Staging Area 에 올라간 상태라면git rm -rf --cached 폴더명으로 해당 폴더를 Staging Area 에서 Working Directory 로 내린다. git status 로 다시 상태를 체크하고 git add 로 staging area 에 다시 올린다. 그리고 다시 git status 로 staging area 에 올라온 상태를 파악하고 git commit 을 한다. CLI 환경에서 (master)가 보이면 git init을 하지 않는게 좋다.","link":"/2022/01/14/git/"},{"title":"data structure","text":"자료구조 (Data Structure) Storegy 데이터가 영구히 저장되는 곳 HDD, SSD, USB, CD … 용량이 크지만 속도가 느림 Memory 데이터가 임시적으로 저장되는 곳 용량이 작지만 속도가 매우 빠름 당장 필요한 데이터가 위치 RAM (Random Access Memory) 각 칸마다 주소값이 지정되어 있음 🧨역사속의 SW 오류, Patriot Misslile 오류🧨 1991년 걸프전, 이라크는 미국을 위시한 연합군을 향해 스커드 미사일을 날려보냈다. 이에 미군의 첨단 방공무기로 알려진 패트리어트 미사일에서 요격 미사일을 발사했다. 하지만 패트리어트는 구형 구소 스커드 미사일 요격에 실패했다. 요격 실패의 원인은 바로 ‘수치 오차’ 소프트웨어에서 시간 값의 형식을 전환하면서 생긴 라운드오프 에러로 시간 오차가 발생하였고 이것이 레인지 게이트의 부정확한 계산으로 이어져 엉뚱한 위치에서 적의 미사일을 찾는 결과를 낳았다. 자료구조 컴퓨터의 메모리를 효율적으로 사용할 수 있도록 데이터를 저장하고 구성하는 방법 linear data structure (선형 자료구조) 자료간의 관계가 1대1의 관계를 갖는다. list, stack, queue, linked list non-linear data structure (비선형 자료구조) 자료간의 관계가 1대 N의 관계를 갖는다. graph, tree 자료구조를 쓰면 좋은 점 데이터의 구조를 전체적으로 파악해서 효율적으로 사용 가능 ADT (Abstract Data Type, 추상 데이터 타입) 구조화된 데이터를 필요한 연산과 함께 묶어서 표현하는 방법","link":"/2022/02/22/data-structure/"},{"title":"hexo 백업하기","text":"Hexo Deploymenthexo generate : Hexo의 각종 템플릿과 .md파일을 통해 웹사이트(html, css, javascripts 등)을 만들어준다. hexo deploy : hexo-deployer-git 플러그인을 이용해서 레파지토리에 있는 public 폴더의 내용을 배포한다. 문제점 😥 : 내가 작성한 마크다운 파일, 설정파일, 테마는 따로 저장되지 않는다 새 저장소 생성하기새 저장소는 총 2개가 필요하다. theme 백업용 blog 백업용 나는 theme 는 기존 테마를 fork 해서 사용하고 있기 때문에 따로 테마용 레포는 생성하지 않았다. 블로그 백업용 레포는 github에 private로 생성했다. 테마 백업하기fork 해 온 테마에서 수정한 부분을 다시 git add, git commit, git push 한다. Hexo 백업하기hexo 폴더는 따로 git으로 관리되고 있지 않기 때문에 초기화부터 시작한다. 1234567891011# .gitignore 파일 만들기# (참고) hexo 프로젝트 생성 시 자동으로 만들어진다. 파일 내부에 다음 내용 있는지 확인하기.$ echo &quot;/public&quot; &gt;&gt; .gitignore$ echo &quot;/node_modules&quot; &gt;&gt; .gitignore$ echo &quot;.deploy_git/&quot; &gt;&gt; .gitignore# git 초기화$ git init$ git add .$ git commit -a 서브모듈 추가하기이미 테마 폴더는 git으로 관리되고 있는 상태. git 안에 git이 있는 경우 submodule 로 관리하는 것이 좋다. 테마 폴더가 제대로 백업이 된 상태라면, themes 내의 테마 폴더를 삭제하고 git submodule을 이용해서 서브모듈로 추가한다. 123456789$ git submodule add {theme 주소}# 상태 확인$ git status$ git submodule status# 변경된 내용 commit$ git add .$ git commit -a 원격 저장소에 백업하기12$ git remote add origin {repo 주소}$ git push -u origin master 다른 컴퓨터에서 블로그 백업 내용 내려받기 (git)12345678# 컴퓨터에 node, hexo 설치되어있는지 확인 필요$ git clone {repo 주소}$ cd themes/{테마 폴더}$ git submodule update --init --recursive$ hexo generate &amp;&amp; hexo server# 에러나는 경우# rm -rf node_modules &amp;&amp; npm install --force# 실행 후 다시 hexo 명령어 실행","link":"/2022/02/22/hexo-%EB%B0%B1%EC%97%85%ED%95%98%EA%B8%B0/"},{"title":"algo&gt;BOJ_2615(오목,실버2)","text":"https://www.acmicpc.net/problem/2615 문제를 풀기 위해서 처음에 얼마나 규칙을 잘 정하고, 예외처리를 잘 하느냐가 중요한 것 같다. 승리한 경우 가장 왼쪽에 있는 바둑알을 검사하기 위해 오른쪽, 아래 방향으로만 검사할 것 오목이 아닌 육목일 경우 (앞에 하나 더 있는지, 뒤에 하나 더 있는지) 검사 필요 승부가 나지 않는 경우 print(0)을 잊지말자 오목의 갯수 세는 변수인 cnt 의 위치 중요 (방향이 달라지면 새로 카운트하기 위해 꼭 1로 초기화 해줘야한다!) 12345678910111213141516171819202122232425262728293031323334353637import sysinput = sys.stdin.readlinedef omok(): di = [-1, 0, 1, 1] # 우상, 우, 우하, 하 dj = [1, 1, 1, 0] for i in range(0, N): # 15번째 줄까지만 검사하면 됨 for j in range(0, N): check = arr[i][j] if check: for dr, dc in zip(di, dj): cnt = 1 # 방향 달라질 때 마다 새로 카운트해야함!! row = i + dr col = j + dc # 인덱스 범위 내에 있고, check 와 같은 색의 돌이 있으면 while 0 &lt;= row &lt; N and 0 &lt;= col &lt; N and arr[row][col] == check: cnt += 1 if cnt == 5: if 0 &lt;=i-dr&lt; N and 0&lt;=j-dc&lt;N and arr[i-dr][j-dc] == check: # 앞쪽에 하나 더 있는지 검사 break if 0 &lt;=row+dr&lt; N and 0&lt;=col+dc&lt;N and arr[row+dr][col+dc] == check: # 뒤쪽에 하나 더 있는지 검사 break # 모두 아니면 결과 출력하고 return 으로 함수 종료 print(check) print(i+1, j+1) return row += dr col += dc # 승부가 결정되지 않았을 경우에는 0을 출력 print(0)N = 19arr = [list(map(int, input().split())) for _ in range(N)]omok()","link":"/2022/02/27/algo-BOJ-2615-%EC%98%A4%EB%AA%A9-%EC%8B%A4%EB%B2%842/"},{"title":"python&gt;OOP","text":"Object-Oriented Programming 1. 객체지향 프로그래밍1.1 객체지향 프로그래밍파이썬은 모두 객체(object)로 이뤄져 있다. 객체(object)는 특정 타입의 인스턴스(instance)이다. 123, 900, 5는 모두 int의 인스턴스 ‘hello’, ‘bye’는 모두 string 의 인스턴스 [232, 89,1], [] 은 모두 list의 인스턴스 객체의 특징 타입 (type) : 어떤 연산자와 조작 가능한가? 속성 (attribute) : 어떤 상태(데이터)를 가지는가? 기능 (method) : 어떤 행위(함수)를 할수 있는가? 객체지향 프로그래밍데이터가 스스로 매소드를 가지고 있고, 그걸 활용해서 데이터가 변화한다. 장점 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 프로그래밍을 더 배우기 싶게 하고 소프트웨어 개발과 보수를 간편하게 한다. 보다 직관적인 코드 분석을 가능하게 한다. 1.2 OOP 기초기본 문법123456789101112# 클래스 정의class Myclass: pass# 인스턴스 생성my_instance = My class()# 메서드 호출my_instance.my_method()# 속성my_instance.my_attribute 클래스와 인스턴스 객체의 틀(클래스)을 가지고, 객체(인스턴스)를 생성한다. 클래스 : 객체들의 분류 인스턴스 : 하나하나의 실체 속성 : 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미 메서드 : 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수) 객체 비교하기 == equal 변수가 참조하는 객체가 동등한(내용이 같은) 경우 True 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님 is idential 두 변수가 동일한 객체를 가리키는 경우 True 1.3 인스턴스1.3.1 인스턴스 변수 인스턴스 변수란? 인스턴스가 개인적으로 가지고 있는 속성 각 인스턴스들의 고유한 변수 생성자 메소드에서 self.&lt;name&gt;으로 정의 인스턴스가 생성된 이후 &lt;instance&gt;.&lt;name&gt;으로 접근 및 할당 1.3.2 인스턴스 메서드1.4 클래스1.5 매소드 정리 인스턴스 메소드 self 매개변수를 통해 동일한 객체에 정의된 속성 및 다른 메소드에 자유롭게 접근 가능 클래스 자체에도 접근 가능 -&gt; 인스턴스 메소드가 클래스 상태를 수정할 수도 있음 클래스 메소드 @classmethod 클래스를 가리키는 cls 매개 변수를 받음 cls 인자에만 접근할 수 있기 때문에 객체 인스턴스 상태를 수정할 수 없음 스태틱 메소드 @staticmethod 임의 개수의 매개변수를 받을 수 있지만, self 나 매개변수는 사용하지 않음 객체 상태나 클래스 상태를 수정할 수 없음 일반 함수처럼 동작하지만 클래스의 이름공간에 귀속됨 주로 해당 클래스로 한정하는 용도로 사용 12345678910111213141516class MyClass: def method(self): return 'instance method', self @classmethod def classmethod(cls): return 'class method', cls @staticmethod def staticmethod(): return 'static method'obj = MyClass()print(obj.method())print(MyClass.classmethod())print(MyClass.staticmethod()) 123('instance method', &lt;__main__.MyClass object at 0x000001F9250A3D30&gt;)('class method', &lt;class '__main__.MyClass'&gt;)static method 인스턴스에서 클래스 메소드, 스태틱 메소드 접근 가능하지만, 일반적으로 그렇게 사용하지는 않는다. 2. 객체 지향의 핵심 개념2.1 추상화2.2 상속 두 클래스 사이 부모 - 자식 관계를 정립하는 것 클래스는 상속이 가능함 모든 파이썬 클래스는 object 를 상속받음 하위 클래스는 상위 클래스에 정의된 속성, 행동, 관계 및 제약 조건을 모두 상속받음 부모 클래스의 속성, 메소드가 자식클래스에 상속되므로, 코드 재사용성이 높아짐 2.2.1 상속 관련 함수와 메소드 isinstance(object, classinfo) classinfo의 instance 이거나 subclass 인 경우 True super() 자식클래스에서 부모 클래스를 사용하고 싶은 경우 상속 정리 파이썬의 모든 클래스는 object 로부터 상속됨 부모 클래스의 모든 요소(속성, 메소드)가 상속됨 2.2.2 다중 상속 두 개 이상의 클래스를 상속받는 경우 상속 받은 모든 클래스의 요소를 활용 가능함 중복된 속성이나 메서드가 있는 경우 상속 순서(먼저 상속된 클래스가 win) 에 의해 결정됨 2.3 다형성 (Polymorphism) 동일한 메소드가 클래스에 따라 다르게 행동할 수 있다. 즉, 서로 다른 클래스에 속해있는 객체들이 동일한 메시지에 대해 다른 방식으로 응답될 수 있다. 2.3.1 메소드 오버라이딩 상속받은 메소드를 재정의 상속받은 클래스에서 같은 이름의 메소드로 덮어씀 부모 클래스의 메소드를 실행시키고 싶은 경우 super를 활용 파이썬에서 오버로딩은 지원하지 않는다 오버라이딩(함수 재정의)만 지원한다. (참고) 연산자 오버로딩은 지원한다. ​ [] + [] = [] , 1+2 = 3 2.4 캡슐화 (Encapsulation) 객체의 일부 구현 내용에 대한 외부로부터 직접적인 액세스를 차단 파이썬에서 암묵적으로 존재하지만, 언어적으로는 존재하지 않음 Public Access Modifier Protected Access Modifier Private Access Modifier","link":"/2022/01/26/python-OOP/"},{"title":"python&gt;데이터 구조 및 활용","text":"1. 순서가 있는 데이터 구조1.1 문자열 (String Type) .replace(ole, new[, count]) 바꿀 대상 글자를 새로운 글자로 바꿔서 반환 count 를 지정하면, 해당 개수만큼만 시행 strip([chars]) 특정한 문자들을 지정하면, 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip) 문자열 지정하지 않으면 공백을 제거함 .split([chars]) 문자열을 특정한 단위로 나눠 리스트로 변환 'separator'.join([iterable]) 반복가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환 12&gt;&gt;&gt; '!'.join('ssafy')'s!s!a!f!y' 1.2 리스트 (List) 순서를 가지는 0개 이상의 객체를 참조하는 자료형 항상 대괄호 형태로 출력 : [] .append(x) 리스트 마지막에 항목 x를 추가 .extend(iterable) 리스트에 iterable 의 항목을 추가함 .insert(i, x) 정해진 위치 i에 값 x를 추가함 i가 리스트 길이보다 큰 경우 맨 위에 추가한다. .remove(x) 리스트에서 값이 x인 것 삭제 (두개 이상 있어도 하나만 삭제) 없는 경우 ValueError .pop(i) 정해진 위치 i에 있는 값을 삭제하고 그 값을 반환함 i가 지정되지 않으면, 마지막 항목을 삭제하고 반환함 .clear() 모든 항목을 삭제함 .index() x 값을 찾아 해당 index값을 반환 없는 경우 ValueError .count(x) 원하는 값의 개수를 반환함 .sort() 원본 리스트를 정렬함. None 반환 sorted 함수와 비교 .sort() : 원본을 변경 sorted : 정렬된 리스트를 반환. 원본 변경 없음 .reverse() 순서를 반대로 뒤집음, None반환 튜플(tuple) 순서를 가지는 0개 이상의 객체를 참조하는 자료형 immutable : 생성 후, 담고 있는 객체 변경이 불가 튜플을 변경할 수 없기 때문에 값에 영향을 미치지 않는 메소드만을 지원 2. 순서가 없는 데이터 구조2.1 셋 (Set) 순서없이 0개 이상의 해시 가능한 객체를 참조하는 자료형 mutable : 담고있는 객체를 삽입 변경, 삭제 가능 .add(elem) 셋에 값을 추가 .update(*others) 여러 값을 추가 .remove(elem) 셋에서 삭제하고, 없으면 KeyError .discard(elem) 셋에서 삭제하고 없어도 에러가 발생하지 않음 .pop() 임의의 원소를 제거해 반환 2.2 딕셔너리 (Dictionary) 순서 없이 key-value 쌍으로 이루어진 객체를 참조하는 유형 .get(key[,default]) key 를 통해 value를 가져옴 KeyError 가 발생하지 않으며, defult 값을 설정할 수 있음 (기본: None) .pop(key[,default]) key 가 딕셔너리에 있으면 제거하고 해당 값을 반환 그렇지 않으면 default 를 반환 default 값이 없으면 KeyError .update() 값을 제공하는 key, value 로 덮어씀 123456&gt;&gt;&gt; mydict = {'apple':'사', 'banana':'바나나'}&gt;&gt;&gt; print(mydict){'apple': '사', 'banana': '바나나'}&gt;&gt;&gt; mydict.update(apple='사과')&gt;&gt;&gt; print(mydict){'apple': '사과', 'banana': '바나나'} 3. 얕은 복사(Shallow Copy) 와 깊은 복사(Deep Copy)3.1 할당 (Assignment)대입 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사 12origin = [1,2]copy = origin 3.2 얕은 복사 (Shallow copy)slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소) 123a = [1,2,3]b = a[:]b[0] = 5 얕은 복사 주의사항 복사하는 리스트의 원소가 주소를 참조하는 경우 deep copy 해야한다. 12345678a = [1,2,['a','b']]b = a[:]print(a, b)b[2][0] = 0print(a, b) [1, 2, ['a', 'b']] [1, 2, ['a', 'b']][1, 2, [0, 'b']] [1, 2, [0, 'b']] 3.3 깊은 복사 (Deep copy)import copy 12345678910import copya = [1,2,['a','b']]b = copy.deepcopy(a)print(a, b)b[2][0] = 0print(a, b)[1, 2, ['a', 'b']] [1, 2, ['a', 'b']][1, 2, ['a', 'b']] [1, 2, [0, 'b']]","link":"/2022/01/24/python-%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-%E1%84%86%E1%85%B5%E1%86%BE-%E1%84%92%E1%85%AA%E1%86%AF%E1%84%8B%E1%85%AD%E1%86%BC/"},{"title":"python&gt;데이터&amp;데어문","text":"데이터 &amp; 제어문1. 기초 문법 파이썬에서 제안하는 스타일 가이드 PEP8 (https://www.python.org/dev/peps/pep-0008/) 변수란? 컴퓨터 메모리 어딘가에 저장되어 있는 객체를 참조하기 위해 사용되는 이름 객체 (object) : 숫자, 문자, 클래스 등 값을 가지고 있는 모든 것 파이썬은 객체지향 언어이며, 모든 것이 객체로 구현되어 있음 변수는 할당 연산자(=) 를 통해 값을 할당 type() : 변수에 할당된 값의 타입 id() : 변수에 할당된 값(객체)의 고유한 identity 값이며, 메모리 주소 12345&gt;&gt;&gt; x = 'test'&gt;&gt;&gt; type(x)&lt;class 'str'&gt;&gt;&gt;&gt; id(x)2538867408240 같은 값을 동시에 할당할 수 있음 다른 값을 동시에 할당할 수 있음 (문제) x = 10, y = 20 일 때, 각각 값을 바꿔서 저장하는 코드를 작성하시오. 123456789x,y = 10, 29# 방법1 (주로 사용되는 방법)tmp = xx = yy = tmp# 방법2 (pythonic!)y,x = x,y 식별자 (Identifiers) 파이썬 객체 (변수, 함수, 모듈, 클래스 등) 를 식별하는데 사용하는 이름(name) 규칙 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성 첫 글자에 숫자가 올 수 없음 길이제한이 없고, 대소문자를 구별 다음의 키워드(keywords) 는 예약어(reserved words)로 사용할 수 없음 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; print(keyword.kwlist)['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 내장함수나 모듈 등의 이름으로도 만들면 안됨 기존의 이름에 다른 값을 할당하게 되므로 더 이상 동작하지 않음 주석 (Comment) 한 줄 주석 : # 여러 줄의 주석 : &quot;&quot;&quot; 또는 ''' 2. 파이썬 자료형 2.1 None 파이썬 자료형 중 하나 값이 없음을 표현하기 위한 타입인 NoneType 12345&gt;&gt;&gt; print(type(None))&lt;class 'NoneType'&gt;&gt;&gt;&gt; a = None&gt;&gt;&gt; print(a)None 일반적으로 반환 값이 없는 함수에서 사용하기도 함 2.2 Boolean True/False 값을 가진 타입은 bool 비교/논리 연산을 수행함에 있어서 활용됨 다음은 모두 False로 변환 0, 0.0, (), [], {}, '', None 2.3 수치형 (Numeric Type)2.3.1 int 모든 정수의 타입은 int 매우 큰 수를 나타낼 때 오버플로우가 발생하지 않음 오버플로우 (overflow) : 데이터 타입별로 사용할 수 있는 메모리의 크기를 넘어서는 상황 [파이썬 3에는 오버플로우가 없다.] https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/ 파이썬 2에서는 정수형 데이터 타입이 int와 long 두 가지가 있었는데, int는 C에서의 그것과 같은 4바이트 데이터형이고, long은 arbitrary precision을 따르는 데이터형이다. 그래서 int 타입 변수의 값이 표현 범위를 넘어서게 되면 자동으로 long으로 타입 변경이 되는 형식이었다. 파이썬 3에서는 long 타입이 없어지고 int 타입만 남았는데, 이 int가 arbitrary precision을 지원하여 오버플로우가 발생하지 않게 되었다. 하지만 파이썬3에서도 pydata stack을 사용하는 numpy/pandas 같은 패키지를 사용할 때는 C 스타일이 유지되기 때문에 오버플로우 발생을 고려해야 한다. arbitrary precision?? In computer science, arbitrary-precision arithmetic, also called bignum arithmetic, multiple precision arithmetic, or sometimes infinite-precision arithmetic, indicates that calculations are performed on numbers whose digits of precision are limited only by the available memory of the host system. (Wikipedia) 즉, arbitrary-precision은 사용할 수 있는 메모리양이 정해져 있는 기존의 fixed-precision과 달리, 현재 남아있는 만큼의 가용 메모리를 모두 수 표현에 끌어다 쓸 수 있는 형태를 이야기하는 것 같다. 예를 들어 특정 값을 나타내는데 4바이트가 부족하다면 5바이트, 더 부족하면 6바이트까지 사용할 수 있게 유동적으로 운용한다는 것이다. 진수 표현 123456&gt;&gt;&gt; 0b102&gt;&gt;&gt; 0o3024&gt;&gt;&gt; 0x1016 2.3.2 float 정수가 아닌 모든 실수는 float 타입 부동소수점 실수를 컴퓨터가 표현하는 방법 - 2진수(bit)로 숫자를 표현 이 과정에서 floating point rounding error 가 발생하여 , 예상치 못한 결과가 발생 값 비교하는 과정에서 정수가 아닌 실수인 경우 주의할 것 매우 작은 수보다 작은지를 확인하거나 math 모듈 활용 (math.isclose 추천) 2.3.3 복소수 (Complex)허수부를 j로 표현 123456789&gt;&gt;&gt; a = 3+4j&gt;&gt;&gt; print(type(a))&lt;class 'complex'&gt;&gt;&gt;&gt; a.real3.0&gt;&gt;&gt; a.imag4.0&gt;&gt;&gt; print(a)(3+4j) 2.4 문자열 (String Type) 모든 문자는 str 타입 ' &quot; 를 활용하여 표기 중첩 따옴표 따옴표 안에 따옴표를 표현할 경우 : 작은 따옴표가 들어있는 경우는 큰 따옴표로 문자열 생성 삼중 따옴표 따옴표 안에 따옴표를 넣을 때 여러 줄을 나눠 입력할 때 편리 123456&gt;&gt;&gt; print('''문자열 안에 '작은 따옴표'나&quot;큰 따옴표&quot;를 사용할 수 있고여러 줄을 사용할 때도 편리하다.''')문자열 안에 '작은 따옴표'나&quot;큰 따옴표&quot;를 사용할 수 있고여러 줄을 사용할 때도 편리하다. Escape sequence 문자열 내에서 특정 문자나 조작을 위해서 역슬래시()를 활용하여 구분 String Interpolation 문자열을 변수를 활용하여 만드는 법 %-formatting 123&gt;&gt;&gt; name = 'kim'&gt;&gt;&gt; print('Hello, %s' % name)Hello, kim str.format() 1234&gt;&gt;&gt; name = 'kim'&gt;&gt;&gt; score = 4.5&gt;&gt;&gt; print('Hello, {}! 성적은 {}'.format(name, score))Hello, kim! 성적은 4.5 f-string : python 3.6+ 1234&gt;&gt;&gt; name = 'kim'&gt;&gt;&gt; score = 4.5&gt;&gt;&gt; print(f'Hello, {name}! 성적은 {score}')Hello, kim! 성적은 4.5 2.5 컨테이너 (Container) 여러 개의 값을 담을 수 있는 것(객체)으로, 서로 다른 자료형을 저장할 수 있음 ex) List, tuple 3. 시퀀스형 컨테이너3.1 List - [] 순서를 가지는 0개 이상의 객체를 참조하는 자료형 생성된 이후 내용 변경이 가능 순서가 있는 시퀀스로 인덱스를 통해 접근 가능 3.2 Tuple - () 순서를 가지는 0개 이상의 객체를 참조하는 자료형 생성 후, 담고있는 객체 변경이 불가 수정 불가능한 (immutable) 시퀀스로 인덱스로 접근 가능 123456789101112# 단일 항목의 경우&gt;&gt;&gt; a = 1,&gt;&gt;&gt; print(a)(1,)&gt;&gt;&gt; print(type(a))&lt;class 'tuple'&gt;# 복수 항목의 경우&gt;&gt;&gt; b = 1,2,3&gt;&gt;&gt; print(b)(1, 2, 3)&gt;&gt;&gt; print(type(b))&lt;class 'tuple'&gt; 튜플 대입 우변의 값을 좌변의 변수에 한번에 할당하는 과정 123&gt;&gt;&gt; x, y = (1, 2)&gt;&gt;&gt; print(x, y)1 2 3.3 Range 숫자의 시퀀스를 나타내기 위해 사용 기본형 : range(n) 0부터 n-1 까지 범위 지정 : range(n,m) n부터 m-1까지 범위 및 스텝 지정 : range (n,m,s) n부터 m-1까지 s만큼 증가 3.4 패킹/언패킹 (Packing/Unpacking) *3.4.1 패킹 대입문의 좌변 변수에 위치 우변의 객체 수가 좌변의 변수 수보다 많을 경우 객체를 순서대로 대입 나머지 항목들은 모두 별 기호 표시된 변수에 리스트로 대입 12345&gt;&gt;&gt; x, *y = 1,2,3,4,5&gt;&gt;&gt; print(x, type(x))1 &lt;class 'int'&gt;&gt;&gt;&gt; print(y, type(y))[2, 3, 4, 5] &lt;class 'list'&gt; 3.4.2 언패킹 argument 이름이 * 로 시작하는 경우, argument unpacking 이라 함 언패킹의 경우 튜플 형태로 대입 123456&gt;&gt;&gt; def multiply(x,y,z): return x*y*z&gt;&gt;&gt; numbers = [1,2,3]&gt;&gt;&gt; multiply(*numbers)6 별표(*) 연산자가 곱셈을 의미하는지 Packing/Unpacking 연산자인지 구분 4. 비시퀀스형 컨테이너4.1 Set - {} 순서없이 0개 이상의 해시가능한 객체를 참조하는 자료형 담고 있는 객체를 삽입, 변경, 삭제 가능 -&gt; 가변 자료형(mutable) 집합과 동일한 구조 : 집합 연산 가능, 중복된 값 존재하지 않음 순서가 없어 별도의 값에 접근할 수 없음 빈 중괄호는 dictionary 빈 set을 만들기 위해서는 set()을 반드시 활용해야 함 set의 활용 set을 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음 단, 이후 순서가 무시되므로 순서가 중요한 경우 사용할 수 없음 (순서 무작위) 123&gt;&gt;&gt; my_list = ['서울', '서울', '대전', '구미', '구미']&gt;&gt;&gt; print(set(my_list)){'서울', '대전', '구미'} 4.2 Dictionary 순서없이 key-value 쌍으로 이루어진 객체를 참조하는 자료형 key : 해시 가능한 불변 자료형(immutable)만 가능 value : 어떠한 형태든 관계 없음 (List, Dictionary 등) 생성 방법 1234567&gt;&gt;&gt; dict_a = {'a':'apple', 'b':'banana'}&gt;&gt;&gt; print(dict_a){'a': 'apple', 'b': 'banana'}&gt;&gt;&gt; &gt;&gt;&gt; dict_b = dict(a='apple', b='banana')&gt;&gt;&gt; print(dict_b){'a': 'apple', 'b': 'banana'} 4.3 Typecasting 파이썬에서 데이터 형태는 서로 변환할 수 있음 암시적 형변환 : 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우 명시적 형변환 : int, float, str 5. 연산자 (Operator) 산술 연산자 : +, -, *, /, //, ** 비교 연산자 : &lt;, &lt;=, &gt;, &gt;=, ==, !=, is, is not 논리 연산자 : and, or, not 일반적으로 비교 연산자와 함께 사용됨 결과가 확실한 경우 두번째 값은 확인하지 않음 - 첫번째 값 반환 and 연산에서 첫번째 값이 False 인 경우 무조건 False - 첫번째 값 반환 or 연산에서 첫번째 값이 True 인 경우 무조건 True - 첫번째 값 반환 복합 연산자 : += 멤버십 연산자 : in, not in 시퀀스 포함 여부 확인 식별 연산자 : is 연산자를 통해 동일한 객체인지 확인 가능함 (OOP에서 추가학습) 기타 (Indexing/Slicing) + : 시퀀스 간의 연결 * : 시퀀스를 반복 Indexing : 시퀀스의 특정 인덱스 값에 접근 12&gt;&gt;&gt; [1,2,3][2]3 Slicing : 시퀀스를 특정 단위로 슬라이싱 1234567&gt;&gt;&gt; [1,2,3,4,5][1:4][2, 3, 4]&gt;&gt;&gt; s = 'abcdefghi'&gt;&gt;&gt; s[::]'abcdefghi'&gt;&gt;&gt; s[::-1]'ihgfedcba' set 연산자 | : 합집합 &amp; : 교집합 - : 여집합 ^ : 대칭차 6. 컨테이너 (Container) 정리컨테이너 간의 형 변환은 아래와 같이 가능 7. 제어문 (Control Statement) 파이썬은 기본적으로 위에서부터 아래로 순차적으로 명령을 수행 특정 상황에 따라 코드를 선택적으로 실행(분기/조건)하거나 계속하여 실행하는 제어가 필요함 제어문은 순서도 (flow chart)로 표현이 가능 7.1 조건문7.1.1 조건문 기본 조건문은 참/거짓을 판단할 수 있는 조건식과 함께 사용 아래의 순서도를 코드로 나타내면? 123456a = 5if a &gt; 5: print('5 초과')else: print('5 이하')print(a) 7.1.2 복수 조건문 복수 조건식을 활용할 경우 elif 를 활용하여 표현함 12345678910dust = 80if dust &gt; 150: print('매우나쁨')elif dust &gt; 80: print('나쁨')elif dust &gt; 30: print('보통')else: print('좋음')print('미세먼지 확인 완료') 7.1.3 중첩 조건문 조건문은 다른 조건문에 중첩되어 사용될 수 있음 들여쓰기를 유의하여 작성할 것 7.1.4 조건 표현식 (Conditional Expression) 조건 표현식을 일반적으로 조건에 따라 값을 정할 때 활용 삼항 연산자(Ternary Operator)로 부르기도 함 12&lt;true인 경우 값&gt;if&lt;expression&gt;else&lt;false인 경우 값&gt;value = num if num &gt;= 0 else -num 절대값을 저장하기 위한 코드 7.2 반복문 특정 조건을 도달할 때 까지 계속 반복되는 일련의 문장 7.2.1 while 조건식이 참인 경우 반복적으로 코드를 실행 무한 루프를 하지 않도록 종료 조건이 반드시 필요 1부터 사용자가 입력한 양의 정수까지의 총합을 구하는 코드를 작성하시오 123456789# 값 초기화n = 0total = 0user_input = int(input())# 반복문while n &lt; user_input: total += n n += 1print(total) 7.2.2 for 시퀀스 string, tuple, list, range 를 포함한 순회 가능한 객체 (iterable) 요소를 모두 순회함 처음부터 끝까지 모두 순회하므로 별도의 종료조건이 필요하지 않음 아래 순서도를 코드로 나타내시오 123for fruit in ['apple', 'mango', 'banana']: print(fruit)print('끝') 딕셔너리 (Dictionary) 순회 기본적으로 key 를 순회하며, key 를 통해 값을 활용한다. 1234567891011121314&gt;&gt;&gt; grades = {'john':80, 'eric':90}&gt;&gt;&gt; for student in grades: print(student) johneric&gt;&gt;&gt; grades = {'john':80, 'eric':90}&gt;&gt;&gt; for student in grades: print(student, grades[student]) john 80eric 90 추가 메서드 활용 1234567&gt;&gt;&gt; grades = {'john':80, 'eric':90}&gt;&gt;&gt; print(grades.keys())dict_keys(['john', 'eric'])&gt;&gt;&gt; print(grades.values())dict_values([80, 90])&gt;&gt;&gt; print(grades.items())dict_items([('john', 80), ('eric', 90)]) enumerate() 순회 enumerate(iterable, start=0) 인덱스와 객체를 쌍으로 담은 열거형 객체 반환 (index, value) 형태의 tuple 로 구성된 열거 객체를 반환 12345678&gt;&gt;&gt; members = ['민수', '영희', '철수']&gt;&gt;&gt; for idx, member in enumerate(members): print(idx, member) 0 민수1 영희2 철수 List Comprehension 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법 &lt;expression&gt;for&lt; 변수&gt;in&lt;iterable&gt; &lt;expression&gt;for&lt; 변수&gt;in&lt;iterable&gt;if&lt;조건식&gt; (예시) 1~3의 세제곱의 결과가 담긴 리스트를 만드시오 12&gt;&gt;&gt; [number**3 for number in range(1,4)][1, 8, 27] Dictionary Comprehension 표현식과 제어문을 통해 특정한 값을 가진 딕셔너리를 간결하게 생성하는 방법 key:value for &lt;변수&gt; in &lt;iterable&gt; key:value for &lt;변수&gt; in &lt;iterable&gt; if &lt;조건식&gt; (예시) 1~3 의 세제곱의 결과가 담긴 딕셔너리를 만드시오 12&gt;&gt;&gt; {number:number**3 for number in range(1,4)}{1: 1, 2: 8, 3: 27} 7.2.3 반복문 제어7.2.3.1 break 반복문을 종료 7.2.3.2 continue continue 이후의 코드블록은 수행하지 않고, 다음 반복을 수행 7.2.3.3 for-else 끝까지 반복문을 실행한 이후에 else 문 실행 break 를 통해 중간에 종료되는 경우 else문은 실행되지 않음 123456for char in 'apple': if char == 'b': print('b!') breakelse: print('b가 없습니다.') 7.2.3.4 pass 아무것도 하지 않음 특별히 할 일이 없을 때 자리를 채우는 용도로 사용 반복문 아니어도 사용 가능 1234for i int range(5): if i==3: pass print(i)","link":"/2022/01/17/python-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8D%B0%EC%96%B4%EB%AC%B8/"},{"title":"python&gt;모듈","text":"1. 모듈과 패키지 모듈 특정한 기능을 하는 코드를 파이썬 파일(.py) 단위로 작성한 것 패키지 특정 기능과 관련된 여러 모듈의 집합 패키지 안에는 또 다른 서브 패키지를 포함 모듈과 패키지 불러오기 import 모듈 해당 모듈 전체를 가져온다. 사용하려면 항상 ‘모듈명.메소드’ 와 같이 모듈명을 앞에 붙여주어야 한다. from 모듈 import 메소드/모듈 해당 모듈 내에 있는 특정 메소드나 모듈 내 정의된 변수를 가져온다. 가져온 메소드나 변수를 앞에 모듈명을 붙이지 않고 그대로 사용할 수 있다. 다만, 이름이 같은 변수나 메소드가 존재할 경우 대체된다. 2. 파이썬 표준 라이브러리https://docs.python.org/ko/3/library/index.html 파이썬 패키지 관리자(pip) PyPI (Python Package Index)에 저장된 외부 패키지들을 설치하도록 도와주는 패키지 관리 시스템 pip 는 패키지를 업그레이드 하는 경우 과거 버전을 자동으로 지워줌 pip install/uninstall pip list pip show SomePackage pip freeze 설치된 패키지의 비슷한 목록을 만들지만, pip install 에서 활용되는 형식으로 출력 해당하는 목록을 requirements.txt 으로 만들어 관리함 pip freeze &gt; requirements.txt pip install -r requirements.txt 3. 사용자 모듈과 패키지3.1 모듈 실습 check.py 12345def odd(n): return bool(n % 2)def even(n): return not bool(n % 2) check 모듈 활용 1234import checkcheck.odd(3)check.even(3) 1234from check import *odd(5)even(5) 3.2 패키지 실습 패키지는 여러 모듈/하위 패키지로 구조화 모든 폴더에는 __init.py__ 를 만들어 패키지로 인식 python 3.3 부터는 파일이 없어도 되지만, 하위 버전 호환 및 프레임워크등에서의 동작을 위해 파일 생성을 권장 calcpkg폴더를 생성 calcpkg폴더 안에 __init__.py파일 생성 1# __init__.py 파일은 내용을 비워 둘 수 있음 operation.py 파일 생성 12345def add(a, b): return a + b def mul(a, b): return a * b geometry.py 파일 생성 12345def triangle_area(base, height): return base * height / 2def rectangle_area(width, height): return width * height 패키지 사용 12345678import calcpkg.operationimport calcpkg.geometryprint(calcpkg.operation.add(10, 20))print(calcpkg.operation.mul(10, 20))print(calcpkg.geometry.triangle_area(30, 40)) # geometry 모듈의 triangle_area 함수 사용print(calcpkg.geometry.rectangle_area(30, 40)) # geometry 모듈의 rectangle_area 함수 사용 123430200600.01200 123from calcpkg.operation import *print(add (10, 20))print(mul (10, 20)) 1230200 4. 가상환경 venv Python 3.5 부터 가상환경을 만들고 관리하는 모듈 지원 특정 디렉토리에 가상환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음 python -m venv &lt;폴더명&gt; source venv/Scripts/activate : 가상환경 활성화 deactivate : 가상환경 비활성화","link":"/2022/01/19/python-%EB%AA%A8%EB%93%88/"},{"title":"pattern matching","text":"Brute Force 본문의 문자열을 처음부터 끝까지 차례대로 순회하며 패턴 내의 문자들을 일일이 비교 KMP 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행 패턴을 전처리하여 배열 next[M] 을 구해서 잘못된 시작을 최소화 함 next[M] : 불일치가 발생했을 경우 이동할 다음 위치 시간 복잡도 : O(M+N) 아이디어 설명 텍스트에서 abcdabc 까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용 실패한 텍스트 문자와 P[4]를 비교한다. 매칭이 실패했을 때 돌아갈 곳을 계산한다. (next[]) Boyer-Moore algorithm 보이어-무어 알고리즘 오른쪽에서 왼쪽으로 비교 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘 패턴 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 패턴 길이만큼 이동한다. 오른쪽 끝에 있는 문자가 불일치 하고, 이 문자가 패턴 내에 존재할 경우, 일치하는 문자를 찾아서 점프한다.","link":"/2022/02/22/pattern-matching/"},{"title":"python&gt;참고","text":"1. Immutable &amp; Iterable Immutable : 변경할 수 없음 Iterable : 순회 가능함 ex) 문자열 (String Type) 2. 날짜 출력 datetime 모듈로 시간 출력 가능 123import datetimetoday = datetime.datetime.now()print(today) 12022-01-18 20:53:02.139184 f-srting 1234# interpolation에서 출력형식을 지정할 수 있습니다.# today에 저장된 시간을 YYYY년, mm월, dd일, a요일 로 구분해서 출력해봅시다.# 각각 %y, %m, %A를 사용합니다.print(f'오늘은 {today:%y}년 {today:%m}월 {today:%d}일 {today:%A}') 1오늘은 22년 01월 18일 Tuesday f-strings에서는 연산과 출력형식 지정도 가능 12pi = 3.141592print(f'원주율은 {pi:.3}, 반지름이 2일 때 원의 넓이는 {pi*2*2}') 1원주율은 3.14, 반지름이 2일 때 원의 넓이는 12.566368 3. tuple 생성 시 주의할 점하나의 항목으로 구성된 튜플은 생성 시 값 뒤에 쉼표를 붙여야 한다. 복수 항목의 경우 마지막 항목에 붙은 쉼표는 생략할 수 있다. 1234# 하나의 항목으로 구성된 튜플은 생성 시 값 뒤에 쉼표를 붙여야 합니다.a = 1,print(a)print(type(a)) 12(1,)&lt;class 'tuple'&gt; 1234# 길이가 1인 tuple을 만들 때 쉼표가 없는 경우 어떻게 되는지 확인 해봅시다.tuple_or_not = ('hello')print(tuple_or_not)print(type(tuple_or_not)) 12hello&lt;class 'str'&gt; 4. 컨테이너(Container) 정리 5. 단축평가 (short-circuit evaluation) 첫번째 값이 확실할 때, 두 번째 값은 확인하지 않습니다. 조건문에서 뒷 부분을 판단하지 않아도 되기 때문에 속도가 향상됩니다. and 는 둘 다 True일 경우만 True이기 때문에 첫 번째 값이 True라도 두번째 값을 확인해야 하기 때문에 'b'가 반환됩니다. or 는 하나만 True라도 True이기 때문에 True를 만나면 해당 값을 바로 반환합니다. ex) 123456# and의 단축평가(short-circuit evaluation)에 대해서 알아봅시다.# (3 and 5) , (3 and 0), (0 and 3), (0 and 0) 의 결과를 print로 출력해봅시다.print(3 and 5)print(3 and 0)print(0 and 3)print(0 and 0) 12345000 1234print(5 or 3)print(3 or 0)print(0 or 3)print(0 or 0) 12345330 6. enumerate()인덱스와 값을 함께 활용 가능하다. 숫자를 1부터 카운트 할 수 있다. 123# enumerate() 에 의해 반환되는 인덱스가 1로 시작하여 카운트되는 for 반복문을 작성해봅시다.for idx, member in enumerate(members, start=1): print(idx, member) 1231 민수2 영희3 철수 2021.01.20.목요일 7. 재귀함수 자기 자신을 호출하는 재귀함수는 알고리즘 구현시 많이 사용됩니다. 코드가 더 직관적이고 이해하기 쉬운 경우가 있습니다. 파이썬에서는 최대 재귀 깊이(maximum recursion depth)가 1,000으로 정해져있는데, 알고리즘 문제에 따라 다음과 같이 recursion limit을 재설정해주면 해결되는 경우도 있습니다. 1234import sysprint(sys.getrecursionlimit())sys.setrecursionlimit(5000)print(sys.getrecursionlimit()) 8. ''.join(리스트)함수 매개변수로 들어온 리스트에 있는 요소 하나하나를 합쳐서 하나의 문자열로 바꾸어 반환하는 함수 9. 파이썬 가상 환경 (윈도우)123python -m venv venvsource venv/Scripts/activatedeactivate 10. practice회문 판별 (while vs 재귀) 회문 또는 팰린드롬은 거꾸로 읽어도 제대로 읽는 것과 같은 문장이나 낱말, 숫자, 문자열 등을 말한다. 입력으로 짧은 영어단어 word가 주어질 때, 해당 단어가 회문이면 True 회문이 아니면 False를 반환하는 함수를 작성하시오. 이때, 반복문(while)과 재귀 함수를 사용해서 각각 작성하시오. 1234예시)is_pal_while('tomato') #=&gt; Falseis_pal_while('racecar') #=&gt; Trueis_pal_recursive('azza') #=&gt; True while문을 이용한 풀이1234567891011121314151617181920212223# whiledef is_pal_while(word): while word: # word 길이 구하기 cnt = 0 for w in word: cnt += 1 if cnt &lt;= 1: return True # 첫글자와 끝글자 다른 경우 False 리턴 elif word[0] != word[-1]: return False else: word = word[1:-1] # 더이상 남은 글자 없는 경우 True 리턴 if not word: return True print(is_pal_while('tomato'))print(is_pal_while('racecar'))print(is_pal_while('azza')) 123FalseTrueTrue 재귀를 이용한 풀이123456789101112131415161718# recursivedef is_pal_recursive(word): # word 길이 구하기 cnt = 0 for w in word: cnt += 1 if cnt &lt;= 1: return True elif word[0] == word[-1]: return is_pal_recursive(word[1:-1]) else: return Falseprint(is_pal_recursive('tomato'))print(is_pal_recursive('racecar'))print(is_pal_recursive('azza')) 123FalseTrueTrue","link":"/2022/01/18/python-%EC%B0%B8%EA%B3%A0/"},{"title":"python&gt;함수","text":"1. 함수 기초1.1 함수 (Function) 특정한 기능을 하는 코드의 조각(묶음) 특정 명령을 수행하는 코드를 매번 다시 작성하지 않고, 필요 시에만 호출하여 간편히 사용 함수를 사용해야하는 이유? 코드 중복 방지 재사용 용이 1.2 사용자 함수 (Custom Function) 구현되어 있는 함수가 없는 경우, 사용자가 직접 함수를 작성 가능 123def function_name(parameter): # code block return returning value 2. 함수의 결과값 (Output) void function 명시적인 return 값이 없는 경우, None을 반환하고 종료 1234&gt;&gt;&gt; a = print('test')test&gt;&gt;&gt; print(a)None value returning function 함수 실행 후, return 문을 통해 값 반환 함수는 항상 단일한 값만을 반환 return 문을 한번만 사용하면서 두개 이상의 값을 반환하는 방법? 반환값으로 튜플사용 3. 함수의 입력 (Input)3.1 Parameter와 Argument1234def say_anything(a): # parameter print(f'hello {a}') say_anything('python') # argument 1hello python Parameter : 함수를 실행할 때, 함수 내부에서 사용되는 식별자 Argument : 함수를 호출할 때, 넣어주는 값 Positional Arguments 기본적으로 함수 호출 시 Argument는 위치에 따라 함수 내에 전달됨 Keyword Arguments 직접 변수의 이름으로 특정 Argument를 전달할 수 있음 (함수 호출 시 주의) Keyword Argument 다음에 Positional Argument를 활용할 수 없음 Default Argument Values 기본값을 지정하여 함수 호출 시 argument값을 설정하지 않도록 함 정의된 것 보다 더 적은 개수의 argument들로 호출될 수 있음 (함수 정의 시 주의) 기본값을 가지는 argument 다음에 기본 값이 없는 argument로 정의할 수 없음 Positional Arguments packing/unpacking 여러 개의 positional argument를 하나의 필수 parameter로 받아서 사용 몇 개의 positional argument를 받을지 모르는 함수를 정의할 때 유용 12345def add(*args): for arg in args: print(arg)add(2)add(2,3,4,5) Keyword Arguments packing/unpacking 함수가 임의의 개수 argument 를 keyword argument로 호출될 수 있도록 지정 argument들은 딕셔너리로 묶여 처리되며, parameter에 ** 를 붙여 표현 1234def family(**kwargs): for key, value in kwargs: print(key, &quot;:&quot;, value)family(father='John', mother='Jane', me='John Jr.') 4. 함수의 범위 (Scope) scope global scope : 코드 어디에서든 참조할 수 있는 공간 local scope : 함수가 만든 scope. 함수 내부에서만 참조 가능 variable gloabl variable : global scope 에 정의된 변수 local variable : local scope 에 정의된 변수 4.1 LEGB; 이름 검색 규칙 (Name Resolution)파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있음 아래와 같은 순서로 이름을 찾아나가며, LEGB rule 에 따름 Local scope : 함수 Enclosed scope : 특정 함수의 상위 함수 Global scope : 함수 밖의 변수, import 모듈 Built-in scope : 파이썬 안에 내장되어 있는 함수 또는 속성 4.2 global 현재 코드 블록 전체에 적용되며, 나열된 식별자(이름)이 global variable임을 나타냄 global 에 나열된 이름은 같은 코드블록에서 global 앞에 등장할 수 없음 global 에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함 4.3 nonlocal global을 제외하고 가장 가까운 scope 의 변수를 연결하도록 함 nonlocal 에 나열된 이름은 같은 코드블록에서 nonlocal 앞에 등장할 수 없음 nonlocal 에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함 global 과는 달리 이미 존재하는 이름과의 연결만 가능함 4.4 범위 확인하기 locals() : locals() 가 실행되어지는 함수 내의 local namespace들을 딕셔너리로 정리 globals() : global, local, built-in 정보 모두 딕셔너리로 정리 5. 함수의 문서화 (Doc-String) Docstring 함수나 클래스의 설명 jupyter notebook에서 함수에 커서를 놓고 shift + tab 6. 함수 응용6.1 map (function, iterable) 순회 가능한 데이터구조 (iterable) 의 모든 요소에 함수(function) 을 적용하고, 그 결과를 map object 로 반환 활용 알고리즘 문제 풀이 시 input 값을 숫자로 바로 활용하고 싶을 때 123456&gt;&gt;&gt; n, m = map(int, input().split())1 2&gt;&gt;&gt; print(n, m)1 2&gt;&gt;&gt; print(type(n), type(m))&lt;class 'int'&gt; &lt;class 'int'&gt; 6.2 filter (function, iterable) 순회 가능한 데이터구조 (iterable) 의 모든 요소에 함수(function) 을 적용하고, 그 결과가 True인 것들은 filter object 로 반환 123456&gt;&gt;&gt; numbers = [1,2,3]&gt;&gt;&gt; result = filter(odd, numbers)&gt;&gt;&gt; print(result, type(result))&lt;filter object at 0x0000024EEA0893A0&gt; &lt;class 'filter'&gt;&gt;&gt;&gt; list(result) # 리스트 형변환을 통해 결과 확인[1, 3] 6.3 zip (*iterables) 복수의 iterable 을 모아 튜플을 원소로 하는 zip object 를 반환 1234567&gt;&gt;&gt; girls = ['jane', 'ashley']&gt;&gt;&gt; boys = ['justin', 'eric']&gt;&gt;&gt; pair = zip(girls, boys)&gt;&gt;&gt; print(pair, type(pair))&lt;zip object at 0x0000024EEA0A4E00&gt; &lt;class 'zip'&gt;&gt;&gt;&gt; list(pair) # 리스트 형변환을 통해 결과 확인[('jane', 'justin'), ('ashley', 'eric')] 6.4 lambda [parameter] : 표현식lambda [parameter] : 표현식 표현식을 계산한 결과값을 반환하는 함수고, 이름이 없는 함수여서 익명함수라고도 불림 return 문을 가질 수 없음 간편 조건문 외 조건문이나 반복문을 가질 수 없음 예시 123&gt;&gt;&gt; triangle_area = lambda b, h : 0.5 * b * h&gt;&gt;&gt; triangle_area(5,6)15.0 6.5 재귀 함수 (recursive function) 자기 자신을 호출하는 함수 1개 이상의 base case(종료되는 상황) 가 존재하고, 수렴하도록 작성 주의 사항 base case 에 도달할 때 까지 함수를 호출함 메모리 스택이 넘치게 되면 (stack overflow) 프로그램이 동작하지 않게 됨 파이썬에서는 최대 재귀 깊이 (maximun recursion depth) 가 1,000번으로,호출 횟수가 이를 넘어가게 되면 Recursion Error 발생 반복문과 재귀 함수 비교 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수를 사용함 재귀 호출은 변수 사용을 줄여줄 수 있음 재귀 호출은 입력 값이 커질수록 연산속도가 오래걸림 일급 객체 (1급 객체, First-class citizen) 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 참고 : https://velog.io/@reveloper-1311/%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4First-Class-Object%EB%9E%80 [일급 객체의 조건] 변수에 할당(assginment)할 수 있다. 다른 함수를 인자(argument)로 전달 받는다. 다른 함수의 결과로서 리턴될 수 있다. 함수가 일급 객체이기 때문에 할 수 있는 것? 고차 함수를 만들 수 있다. 콜백(callback)을 사용할 수 있다.","link":"/2022/01/19/python-%ED%95%A8%EC%88%98/"},{"title":"python&gt;에러&#x2F;예외 처리","text":"에러/예외 처리는 알고리즘에서는 거의 쓰이지 않음 나중에 개발 실무에서나 오픈소스 기여 시 활용할 수 있음 1. 에러와 예외 실행 도중 예상치 못한 상황을 맞이하면, 프로그램 실행을 멈춤 예외 (Exception) : 실행 중에 감지되는 에러 모든 내장 예외는 Exception Class 를 상속받아 이뤄짐 사용자 정의 예외를 만들어 관리할 수 있음 2. 예외 처리 try 코드를 실행함 except try 문에서 예외가 발생 시 실행함 as : as 키워드를 활용하여 원본 에러메시지를 사용할 수 있다. else try 문에서 예외가 발생하지 않으면 실행함 finally 예외 발생 여부와 관계없이 항상 실행함 if ... else 와 다른점? if ... else 는 오류가 발생하면 멈출 것이다. try ... except 는 오류가 발생하면 예외 사항에 대한 동작을 수행한다는 차이점이 있다. 3. 예외 발생 시키기 raise 예외를 강제로 발생 assert [조건], [오류 메시지] 조건이 True이면 그대로 코드 진행, False이면 AssertionError 발생 일반적으로 디버깅 용도로 사용","link":"/2022/01/24/python-%EC%97%90%EB%9F%AC-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/"},{"title":"queue&gt;구현","text":"Queue 구현1. list12345678910111213141516171819&quot;&quot;&quot;문제1. 기본 Queue 구현 - 기본 구현 (가변) - 세 개의 데이터 1, 2, 3을 차례로 큐에 삽입 - 큐에서 세 개의 데이터를 차례로 꺼내어 출력 (1, 2, 3을 차례대로 출력해야 함)&quot;&quot;&quot;#1. Queue 생성queue = []#2. Queue에 데이터를 삽입queue.append(1)queue.append(2)queue.append(3)print(queue)#3. Queue에 삽입한 데이터를 출력(First-In-First-Out)print(queue.pop(0))print(queue.pop(0))print(queue.pop(0))print(queue) 12345[1, 2, 3]123[] 2. funtion123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&quot;&quot;&quot;1) 기본 개념선형 큐 기본- 큐의 크기 == 배열의 크기- front: 마지막에 꺼내진 원소의 인덱스- rear: 저장된 마지막 원소의 인덱스초기 상태front, rear = -1, -1공백 상태 - front = rear포화 상태 - Queue가 전부 찼을 때 - rear = n - 1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)2) 기본 Queue의 연산 과정1. 공백 Queue 생성 - 고정 배열에서 Queue의 사이즈를 지정 - front와 rear의 값을 -1로 초기화 - 이때 파이썬에서 음수 인덱스 유의2. 원소 A 삽입 삽입 과정은 rear의 증가 - front → -1 - rear → 0 (+1)3. 원소 B 삽입 삽입 과정은 rear의 증가 - front → -1 - rear → 1 (+1)4. 원소 반환/삭제 삭제 과정은 front의 증가 - front → 0 (+1) - 이때 해당 자리에 있었던 원소 반환 - rear → 15. 원소 C 삽입 - front → 0 - rear → 2 (+1)6. 원소 반환/삭제 - front → 1 (+1) - rear → 27. 원소 반환/삭제 - front → 2 (+1) - rear → 2 - front와 rear가 같아진다? → 공백 상태&quot;&quot;&quot;&quot;&quot;&quot;문제2. 고정 배열 크기의 Queue 구현 - 세 개의 데이터 1, 2, 3을 차례로 큐에 삽입 - 큐에서 세 개의 데이터를 차례로 꺼내어 출력 (1, 2, 3을 차례대로 출력해야 함)&quot;&quot;&quot;# Queue의 사이즈 지정 - createQueue# 고정 크기의 배열로 Queue를 생성하는 것이 상대적으로 가변 배열(리스트)보다 빠르다.SIZE = 4Q = [0] * SIZE# 초기 상태의 표현front, rear = -1, -1# isFulldef is_full(): &quot;&quot;&quot; Queue가 포화상태인지 확인 - 리스트에서는 큰 문제가 되지 않지만 고정 배열의 경우 확인 필요 &quot;&quot;&quot; # global 키워드를 사용하는 이유? -&gt; https://stackoverflow.com/questions/1261875/python-nonlocal-statement # 단순 '참조'만 하는 것이면 LEGB Rule에 따라 전역 영역의 변수를 참조 # 하지만 함수 내부에서 특정 값을 '참조'하고 &amp; '변경'하기 위해서는 global 키워드 사용하여 전역에 있는 변수를 로컬 변수처럼 활용 global rear return rear == len(Q) - 1# isEmptydef is_empty(): &quot;&quot;&quot; Queue가 공백상태인지 확인 &quot;&quot;&quot; global front, rear return front == rear# enQueuedef enqueue(item): &quot;&quot;&quot; Queue의 뒤쪽(rear 다음)에 원소를 삽입 - rear를 뒤쪽으로 옮기고 (rear + 1)그 자리에 원소를 삽입 - Stack의 top을 옮겨놓고 그 자리에 요소를 넣었던 것을 떠올리자 &quot;&quot;&quot; global rear if is_full(): print(&quot;Queue is full!&quot;) else: rear += 1 Q[rear] = item# deQueuedef dequeue(): &quot;&quot;&quot; Queue의 앞쪽(front)에서 원소를 삭제하고 반환 - front를 뒤쪽으로 옮기고(front + 1) 그 자리에 있는 원소를 반환하며 삭제 &quot;&quot;&quot; global front if is_empty(): return &quot;Queue is empty!&quot; else: front += 1 return Q[front]# Qpeekdef Qpeek(): &quot;&quot;&quot; Queue의 앞쪽(front)의 한 자리뒤(front+1)에서 원소를 삭제없이 반환 - front의 값을 단순하게 증가시켜 가져온다. (큐의 첫 번째 원소 반환) - 이때 중요한 것은 dequeue와 다르게 front의 값 자체를 '변경'하지 않는다는 점 - front += 1은 front + 1과 다르다. - dequeue와 비교하며 생각 &quot;&quot;&quot; global front, rear if is_empty(): print(&quot;Queue is empty!&quot;) else: return Q[front + 1]#1. Queue 초기화 상태 확인print(Q)#2. Queue가 비었는지 확인print(is_empty()) # True#3. enQueue 작업 &amp; 확인enqueue(1)enqueue(2)enqueue(3)enqueue(4)enqueue(5) # Queue is full!print(Q)#4. Qpeekprint(Qpeek())#5. deQueue 작업 &amp; 확인print(dequeue()) # 1print(dequeue()) # 2print(dequeue()) # 3print(dequeue()) # 4print(dequeue()) # Queue is empty! 12345678910[0, 0, 0, 0]TrueQueue is full![1, 2, 3, 4]11234Queue is empty! 3. class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&quot;&quot;&quot;문제 3. 기본 Queue 구현 - 클래스 구현 - 세 개의 데이터 1, 2, 3을 차례로 큐에 삽입 - 큐에서 세 개의 데이터를 차례로 꺼내어 출력 (1, 2, 3을 차례대로 출력해야 함)&quot;&quot;&quot;class Queue: # 생성자 함수 def __init__(self, size): &quot;&quot;&quot; 인스턴스 생성 시에 새로운 Queue 생성 인스턴스 변수 생성 &quot;&quot;&quot; self.size = size self.front = -1 self.rear = -1 self.items = [None] * size # isEmpty def is_empty(self): &quot;&quot;&quot; Queue에 비어있는지 여부를 True / False로 반환 &quot;&quot;&quot; return self.front == self.rear # isFull def is_full(self): &quot;&quot;&quot; Queue에 데이터가 가득 저장되어 있는지 True / False 로 반환 &quot;&quot;&quot; return self.rear == self.size - 1 # enQueue def enqueue(self, item): &quot;&quot;&quot; Queue에 원소 삽입 &quot;&quot;&quot; if self.is_full(): # print(&quot;Queue is full!&quot;) raise Exception(&quot;Queue is full!&quot;) else: self.rear += 1 self.items[self.rear] = item # deQueue def dequeue(self): &quot;&quot;&quot; Queue에서 원소 삭제 후 반환 &quot;&quot;&quot; if self.is_empty(): return &quot;Queue is empty!&quot; else: self.front += 1 return self.items[self.front] def Qpeek(self): &quot;&quot;&quot; Queue에서 바로 다음에 나올 값 확인 &quot;&quot;&quot; if self.is_empty(): # return &quot;Queue is empty!&quot; raise Exception(&quot;Queue is empty!&quot;) else: return self.items[self.front + 1] # length def __len__(self): &quot;&quot;&quot; Queue의 길이 반환 (들어있는 데이터 개수) &quot;&quot;&quot; return self.rear - self.front#1. queue 인스턴스 생성 size 는 5Q = Queue(5)#2. queue가 비었는지 확인print(Q.is_empty())#3. 1, 2, 3 원소를 queue에 삽입Q.enqueue(1)Q.enqueue(2)Q.enqueue(3)#4. 원소가 정상적으로 삽입되었는지 확인 / 길이 확인 / 비었는지 여부 확인print(Q)print(len(Q))print(Q.is_empty())#5. queue에서 원소 삭제 후 반환 &amp; 원소 확인 / 길이 확인item = Q.dequeue()print(item)print(len(Q))#6. queue가 가득차도록 값 추가Q.enqueue(4)Q.enqueue(5)print(Q.is_full())#7. 가득 차 있는 상태에서 값 추가# Q.enqueue(6) 1234567True&lt;__main__.Queue object at 0x0000018C31218FD0&gt;3False12True 4. import12345678910111213141516171819202122&quot;&quot;&quot;문제 4. 기본 Queue 구현 - 기본 구현 (내장 모듈 활용) - 세 개의 데이터 1, 2, 3을 차례로 큐에 삽입 - 큐에서 세 개의 데이터를 차례로 꺼내어 출력 (1, 2, 3을 차례대로 출력해야 함)&quot;&quot;&quot;import queue#1. Queue 생성q = queue.Queue()print(q.empty())#2. Queue에 데이터를 삽입q.put(1)q.put(2)q.put(3)print(q.empty())print(q.full())print(q.qsize())#3. Queue에 삽입한 데이터를 출력(First-In-First-Out)print(q.get())print(q.get())print(q.get())print(q.empty()) 12345678TrueFalseFalse3123True","link":"/2022/02/25/queue-%EA%B5%AC%ED%98%84/"},{"title":"stack","text":"스택 물건을 쌓아 올린듯, 자료를 쌓아 올린 형태의 자료구조 LIFO (Last-In-First-Out, 후입선출) : 가장 마지막에 들어간 것이, 가장 처음에 나온다. 가장 위에서만 데이터의 삽입&amp;삭제가 일어난다. 스택의 연산 (메서드) createstack : 스택을 생성하는 연산, size 필요 isempty : 스택이 현재 비어있는지를 확인, true/false 리턴 isfull : 스택이 현재 꽉 차있는지를 확인, true/false 리턴 push : 스택에 새로운 데이터 요소를 삽입하는 연산 pop : 스택에서 가장 위에 있는 요소를 제거하는 연산, 데이터 반환 peek : 스택에서 가장 위에 있는 요소를 반환하는 연산 (데이터를 확인하고 싶은 경우) 스택의 데이터 구조 top : 스택의 가장 위에 있는 위치를 저장하고 있는 데이터 size : 스택의 크기를 저장하고 잇는 데이터 items : 스택에 담길 데이터를 저장 스택의 삽입/삭제 과정 push top을 증가시킴 top이 가리키는 자리에 원소를 저장 pop 원소를 반환함 top 을 감소시킴 스택의 응용 1: 괄호 검사 조건 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다. 괄호 사이에는 포함 관계만 존재한다. 문자열에 있는 괄호를 차례대로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입, 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사한다. 이때, 스택이 비어있으면 조건 1 또는 조건 2에 위배되고, 짝이 맞지 않으면 조건 3에 위배된다. 마지막 괄호까지 조사한 후에도 스택에 괄호가 남아있으면 조건 1에 위배된다. 스택의 응용 2 : function call 프로그램에서 함수 호출과 복귀에 따른 수행 순서를 관리 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(stack frame) 에 저장하여 시스템 스택에 삽입 함수의 실행이 끝나면 시스템 스택의 top 원소를 삭제(pop)하면서 프레임에 저장되어있던 복귀주소를 확인하고 복귀 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다. 재귀호출 자기 자신을 호출하여 순환 수행되는 것 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 Memoization &amp; DPMemoization 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술 💡동적 계획법의 핵심 123456789# memo 를 위한 배열을 할당하고, 모두 0으로 초기화# memo[0]을 0으로 memo[1]는 1로 초기화 한다.memo = [0,1]def fibo1(n): global memo if n &gt;= 2 and len(memo) &lt; n: memo.append(fifo1(n-1) + fifo(n-2)) return memo[n] DP (Dynamic Programming) 동적 계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. Memoization 과의 차이점 Memoization은 함수의 실행 결과를 저장하는 것이라면, DP는 이전 값을 이용해 다음 값을 얻을 수 있다. 중복계산을 피하기 위해 계산결과를 저장해두는 Memoization을 사용할 수 있다. 분할 정복 과의 차이점 분할 정복도 큰 문제를 작은 문제로 나누어 푸는 것이 동적 계획법과 같지만, 계산한 부분문제를 한번만 사용하고 더이상 쓰지 않는다. 먼저 입력 크기가 작은 부분문제들을 모두 해결한 후에, 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다. 문제를 부분 문제로 분할한다. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분문제부터 해를 구한다. 그 결과는 테이블에 저장하고, 테이블에 저장된 부분문제의 해를 이용하여 상위 문제의 해를 구한다. 12345def fibo2(n): f = [0,1] for i in range(2, n+1): f.append(f[i-1]+f[i-2]) return f[n] DP의 구현 방식 recursive 방식 : fibo1() iterative 방식 : fibo2() memoization 을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능면에서 보다 효율적이다. 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다. DFS 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요 두가지 방법 너비 우선 탐색 (Breadth First Search, BFS) 깊이 우선 탐색 (Depth First Search, DFS) 재귀를 이용해서 구현 반복을 이용해서 구현 - stack 사용 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용 시작 정점 v를 결정하여 방문한다. 정점 v에 인접한 정점 중에서 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push 하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2를 반복한다. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop 하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2를 반복한다. 스택이 공백이 될 때 까지 2를 반복한다. 12345678910111213141516visited[], stack[] 초기화DFS(v) v 방문; visited[v] &lt;- true; do { if (v의 인접 정점 중 방문 안한 w 찾기) push(v); while(w){ w 방문; visited[w] &lt;- true; push(w); v &lt;- w; v의 인접 정점 중 방문 안한 w 찾기 } v &lt;- pop(stack); } while(v) 스택의 응용계산기 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다. 중위 표기법(Infix notation)을 후위 표기법(Postfix notation) 으로 변환하는 방법 ‘(‘를 만나면 스택에 push 한다. ‘)’를 만나면 스택에서 ‘(‘ 가 나올때 까지 pop 하여 출력하고, ‘(‘ 는 pop하여 버린다. 연산자를 만나면 스택에서 그 연산자보다 낮은 우선순위의 연산자를 만날 때 까지 pop 하여 출력한 뒤에 자신을 push 한다. 피 연산자는 그냥 출력한다. 모든 입력이 끝나면 스택에 있는 연산자들을 모두 pop 하여 출력한다. 후위 표기법 수식의 계산 숫자를 만나면 숫자는 스택에 push한다. 연산자를 만나면 스택에서 pop을 두번 하여 그 두 데이터를 가지고 연산한 다음 결과를 스택에 push 한다. 백트래킹 해를 찾는 도중에 ‘막히면’ (즉, 해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다. 결정문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 ‘yes’ 또는 ‘no’ 로 답하는 문제 문제 url 미로찾기 https://www.acmicpc.net/problem/2178 n-Queen https://www.acmicpc.net/problem/9663 Map coloring 부분집합의 합(Subset Sum) https://www.acmicpc.net/problem/1182 백트래킹과 DFS의 차이 깊이 우선 탐색이 모든 경로를 추적하는데 비해, 백트래킹은 불필요한 경로를 조기에 차단 Pruning (가지치기) : 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임 [ 일반 백트래킹 알고리즘] 1234567def checknode(v): if promising(v): if there is a solution at v: write the solution else: for u in each child of v: checknode(u) [부분집합 구하기] 1234567891011121314151617181920212223def backtrack(a,k,input): global MAXCANDIDATES c = [0] * MAXCANDIDATES if k == input: process_solution(a,k) # 답이면 원하는 작업을 한다. else: k += 1 ncandidates = construct_candidates(a,k,input,c) for i in range(ncandidates): a[k] = c[i] backtrack(a,k,input) def construct_candidates(a,k,input,c): c[0] = True c[1] = False return 2 MAXCANDIDATES = 2NMAX = 4a = [0] * NMAXbacktrack(a,0,3)","link":"/2022/02/22/stack/"},{"title":"Markdown","text":"마크다운 (Markdown)일반 텍스트 기반의 경량 마크업(Markup) 언어 직관적이고 관리하기 쉬움 문서의 구조를 잡기 위한 (텍스트에 역할 부여) 언어이므로, 스타일링으로 사용하는 것은 비추! 마크다운 문법 알아보기1. 제목 (Heading) h1 ~ h6 에 해당하는 제목을 표현가능 # 을 사용 예시 123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 제목1제목2제목3제목4제목5제목6 2. 목록 (List) 순서가 없는 목록과 순서가 있는 목록을 표현할 수 있음 순서가 없는 목록은 -, *, + 를 사용 순서가 있는 목록은 1. (숫자. 형태) 를 사용 tab 키를 이용해서 들여쓰기 가능 shift + tab키를 이용해서 내어쓰기 가능 예시 123456789101112131415- 순서가 없는 목록 + 서브 목록 * 서브 목록1. 순서가 있는 목록 1. 서브 목록 2. 서브 목록- 순서가 없는 목록 1. 서브 목록으로 순서가 있는 리스트 2. 서브 목록으로 순서가 있는 리스트1. 순서가 있는 목록 - 서브 목록으로 순서가 없는 리스트 - 서브 목록으로 순서가 없는 리스트 순서가 없는 목록 서브 목록 서브 목록 순서가 있는 목록 서브 목록 서브 목록 순서가 없는 목록 서브 목록으로 순서가 있는 리스트 서브 목록으로 순서가 있는 리스트 순서가 있는 목록 서브 목록으로 순서가 없는 리스트 서브 목록으로 순서가 없는 리스트 3. 강조 글자의 스타일링을 표현 굵게 : **글자** 혹은 __글자__ 기울이기 : *글자* 혹은 _글자_ 취소 : ~~글자~~ 4. 코드 표현 한 줄 코드 표현 (lnline 코드) : print('Hello World') 백틱(`) 으로 감싸서 표현 여러 줄 코드 표현 (block 코드) : 백틱 3개를 연달아 작성 1print('Hello world') 5. 링크 (link) 클릭했을 때 해당 주소로 이동할 수 있는 링크를 표현 [표시할 글자](이동할 주소) 예시 1[google](https://google.com) 을 누르면 구글로 이동합니다. google 을 누르면 구글로 이동합니다. 6. 이미지 ![이미지가 없을 때 나오는 텍스트](이미지가 위치한 경로) 1![펭수](https://ww.namu.la/s/200b12d8096ace4b14fad5783b72ded273dd4eab1317b6a3455a7ab95e80d06d7d49f4dd92ffb9502afa4e9be50398e229fba3e3541e3a77f64d3e480d3e0e347cc652051363ecff054134ce1dc9d640) 7. 인용문 주석이나 인용 문구 표현 &gt;를 사용 123&gt; 인용문을 작성합니다.&gt;&gt; 중첩 인용1&gt;&gt;&gt; 중첩 인용2 인용문을 작성합니다. 중첩 인용1 중첩 인용2 8. 테이블 파이프(|)와 하이픈(-)을 이용해서 행과 열을 구분 하이픈으로 칼럼명과 행을 구분할 때는 3개 이상으로 작성해야 한다. 다음은 테이블 작성 예시와 결과입니다. 1234| 동물 | 종류 | 다리 개수 ||---|---|---|| 호랑이 | 포유류 | 4개 || 닭 | 조류 | 2개 | 동물 종류 다리 개수 호랑이 포유류 4개 닭 조류 2개 But, ctrl + t 를 눌러서 편하게 사용하자!!! 9. 수평선 구분선 - * - 를 3개 이상 연속으로 작성 makrdownguide.org typora markdown reference","link":"/2022/01/13/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/"},{"title":"엔디안 (Endianness)","text":"엔디안 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며, HW 아키텍처마다 다르다. 💡주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바르게 이해하지 않으면 오류를 발생 시킬 수 있다. 빅 엔디안 (Big-endian) 보통 큰 단위가 앞에 나옴, 네트워크 리틀 엔디안 (Little-endian) 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터 종류 0x1234 0x12345678 빅 엔디안 12 34 12 34 56 78 리틀 엔디안 34 12 78 56 34 12 엔디안 확인 코드12import sysprint(sys.byteorder)","link":"/2022/03/23/%EC%97%94%EB%94%94%EC%95%88-Endianness/"},{"title":"queue","text":"Queue 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조 선입선출 (FIFO : First In First Out) 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다. 큐의 선입선출 구조 Front : 마지막으로 삭제된 위치 Rear : 마지막으로 저장된 위치 큐의 기본 연산 enQueue (item) : 큐의 뒤쪽 (read 다음) 에 원소를 삽입하는 연산 deQueue() : 큐의 앞쪽 (front) 에서 원소를 삭제하고 반환하는 연산 createQueue() : 공백상태의 큐를 생성하는 연산 isEmpty() : 큐가 공백상태인지를 확인하는 연산 isFull() : 큐가 포화상태인지를 확인하는 연산 Qpeek() : 큐의 앞쪽 (front) 에서 원소를 삭제없이 반환하는 연산 큐의 연산 과정 선형큐 1차원 배열을 이용한 큐 큐의 크기 = 배열의 크기 front : 저장된 첫번째 원소의 인덱스 rear : 저장된 마지막 원소의 인덱스 상태표현 초기상태 : front = rear = -1 공백상태 : front == rear 포화상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스) 선형 큐의 구현 초기 공백 큐 생성 크기 n 인 1차원 배열 생성 front와 rear 를 -1 로 초기화 삽입 : enQueue(item) 마지막 원소 뒤에 새로운 원소를 삽입하기 위해 rear 값을 증가시켜 새로운 원소를 삽입할 자리를 마련 그 인덱스에 해당하는 배열원소 Q[rear] 에 item 을 저장 123456def enQueue(item): global rear if isFull() : print(&quot;Queue_Full&quot;) else: rear &lt;- rear + 1 Q[rear] &lt;- item 삭제 : deQueue() 가장 앞에 있는 원소를 삭제하기 위해 front 값을 하나 증가시켜 큐에 남아있게 될 첫 번째 원소 이동 새로운 첫번째 원소를 리턴함으로써 삭제와 동일한 기능함 123456def deQueue(): if isEmpty(): Queue_Empty() else: front &lt;- front + 1 return Q[front] 공백상태 및 포화상태 검사 : isEmpty(), isFull() 공백상태 : front == rear 포화상태 : rear == n-1 1234def isEmpty(): return front == reardef isFull(): return rear == len(Q) - 1 검색 : Qpeek() 가장 앞에 있는 원소를 검색하여 반환하는 연산 현재 front의 한자리 뒤 (front+1) 에 있는 원소, 즉 큐의 첫번째에 있는 원소를 반환 12345def Qpeek(): if isEmpty(): print(&quot;Queue_Empty&quot;) else: return Q[front + 1] 선형 큐 이용시 문제점 잘못된 포화상태 인식 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear = n-1 인 상태 즉, 포화상태로 인식하여 더이상의 삽입을 수행하지 않게 됨 해결방법 1 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐 해결방법 2 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용 원형 큐의 논리적인 구조 ​ 원형 큐 초기 공백 상태 front = rear = 0 Index 의 순환 front 와 rear의 위치가 배열의 마지막 인덱스인 n-1 을 가리킨 후, 그 다음에 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함 이를 위해 나머지 연산자 mod 를 사용함 front 변수 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠 삽입 위치 및 삭제 위치 삽입 위치 삭제 위치 선형큐 rear = rear + 1 front = front + 1 원형큐 rear = (rear + 1) mod n front = (front + 1) mod n 원형 큐의 연산 과정 원형 큐의 구현 초기 공백 큐 생성 크기 n 인 1차원 배열 생성 front와 rear를 0으로 초기화 공백상태 및 포화상태 검사 : isEmpty(), isFull() 공백상태 : front == rear 포화상태 : 삽입할 rear의 다음위치 == 현재 front (rear + 1) mod n == front 1234def ifEmpty(): return front == reardef isFull(): return (rear + 1) % len(cQ) == front 삽입 : enQueue(item) 마지막 원소 뒤에 새로운 원소를 삽입하기 위해 rear값을 조정하여 새로운 원소를 삽입할 자리를 마련함 : rear &lt;- (rear + 1) mod n 그 인덱스에 해당하는 배열원소 cQ[rear]에 item을 저장 1234567def enQueue(item): global rear if isFull(): print(&quot;Queue_Full&quot;) else: rear = (rear + 1) % len(cQ) cQ[rear] = item 삭제 : deQueue(), delete() 가장 앞에 있는 원소를 삭제하기 위해 front값을 조정하여 삭제할 자리를 준비함 새로운 front 원소를 리턴함으로써 삭제와 동일한 기능함 1234567def deQueue(): global front if isEmpty(): print(&quot;Queue_Empty&quot;) else: front = (front + 1) % len(cQ) return cQ[front] 123456def delete(): global front if isEmpty(): print(&quot;Queue_Empty&quot;) else: front = (front + 1) % len(cQ) 우선순위 큐(Priority Queue) 우선순위를 가진 항목들을 저장하는 큐 FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다. 우선순위 큐의 적용분야 시뮬레이션 시스템 네트워크 트래픽 제어 운영체제의 테스크 스케줄링 트리 구조 사용 큐의 활용 : 버퍼 (Buffer) 버퍼 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미 버퍼의 자료구조 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다. 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다. BFS (Breadth First Search) 너비우선탐색 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야하므로, 선입선출 형태의 자료구조인 큐를 활용함 다음과 같은 순서로 탐색 123456789101112def BFS(G, v): # 그래프 G, 탐색 시작점 v visited = [0]*(n+1) # n : 정점의 개수 queue = [] # 큐 생성 queue.append(v) # 시작점 v를 큐에 삽입 while queue: # 큐가 비어있지 않은 경우 t = queue.pop(0) # 큐의 첫번째 원소 반환 if not visited[t] # 방문되지 않은 곳이라면 visited[t] = True # 방문한 것으로 표시 visit(t) # 정점 t에서 할일 for i in G[t]: # t와 연결된 모든 정점에 대해 if not visited[i]: # 방문되지 않은 곳이라면 queue.append(i) # 큐에 넣기 123456789101112def BFS(G, v, n): # 그래프 G, 탐색 시작점 v visited = [0]*(n+1) # n : 정점의 개수 queue = [] # 큐 생성 queue.append(v) # 시작점 v를 큐에 삽입 visited[v] = 1 while queue: # 큐가 비어있지 않은 경우 t = queue.pop(0) # 큐의 첫번째 원소 반환 visit(t) for i in G[t]: # t와 연결된 모든 정점에 대해 if not visited[i]: # 방문되지 않은 곳이라면 queue.append(i) # 큐에 넣기 visited[i] = visited[n] + 1 # n으로 부터 1만큼 이동 탐색의 목적에 따라 DFS/BFS 적절히 활용하면 중복 탐색을 줄일 수 있다. ex) 최단거리는 DFS 미로탐색 (SWEA 5105) 출발-도착 최소 이동거리 1234567151310110101101011010110021 1#1 5 1234567891011121314151617181920212223242526272829303132# bfsdef fstart(N): for i in range(N): for j in range(N): if maze[i][j] == 2: return i, j return -1, -1 # 못찾으면 -1 리턴def bfs(i,j,N): visited = [[0]*N for _ in range(N)] # 미로의 크기만큼 생성 queue = [] # 큐 생성 queue.append(i,j) # 시작점 enqueue visited[i][j] = 1 # 시작점 방문표시 while queue: # 큐가 비어있지 않으면 반복 i, j = queue.pop(0) # dequeue if maze[i][j] == 3: return visited[i][j] - 2 # 출발, 도착 칸 제외 for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]: # i, j 인접한 칸에 대해 ni, nj = i+di, j+dj # 주변 칸 좌표 if 0&lt;=ni&lt;N and 0&lt;=nj&lt;N and maze[ni][nj]!=1 and visited[ni][nj]==0: # 주변 칸 좌표가 미로를 벗어나지 않고, 벽이 아니고, 방문한적이 없으면 queue.append((ni,nj)) visited[ni][nj] = visited[i][j] + 1 return 0 # 도착지를 찾지 못한 경우 T = int(input())for tc in range(1,T+1): N = int(input()) maze = [list(map(int, input())) for _ in range(N)] sti, stj = fstart(N) ans = bfs(sti, stj, N) print(f'#{tc} {ans}') 12345678910111213141516171819202122232425262728293031# dfs (재귀)def fstart(N): for i in range(N): for j in range(N): if maze[i][j] == 2: return i, j return -1, -1 # 못찾으면 -1 리턴def dfs(i,j,N,c): # 지나온 칸 수 global minV if maze[i][j] == 3: # 목적지에 도착하면 최소거리와 비교 if minV &gt; c: minV = c else: maze[i][j] = 1 for di,dj in [[0,1],[1,0],[0,-1],[-1,0]]: ni, nj = i+di, j+dj if 0&lt;=ni&lt;N and 0&lt;=nj&lt;N and maze[ni][nj]!=1: dfs(ni,nj,N,c+1) maze[i][j] = 0 T = int(input())for tc in range(1,T+1): N = int(input()) maze = [list(map(int, input())) for _ in range(N)] sti, stj = fstart(N) minV = 10000 dfs(sti,stj,N,0) if minV == 1000: minV = 1 print(f'#{tc} {minV-1}') # 출발지 제외하고 출력","link":"/2022/02/25/queue/"},{"title":"tree","text":"트리 비선형 구조 원소들 간에 1:N 관계를 가지는 자료구조 원소들 간에 계층 관계를 가지는 계층형 자료구조 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조 용어 정리 한 개 이상의 노드로 이루어진 유한집합이며 다음 조건을 만족한다. 루트(root) : 노드 중 최상위 노드 노드(node) : 트리의 원소 간선(edge) : 노드를 연결하는 선, 부모 노드와 자식 노드를 연결 루트 노드(root node) : 트리의 시작 노드 형제 노드(sibling node) : 같은 부모 노드의 자식 노드들 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들 서브 트리(subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들 차수(degree) 노드의 차수 : 노드에 연결된 자식 노드의 수 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값 단말 노드(leaf node) : 차수가 0 인 노드. 자식 노드가 없는 노드 높이 (=레벨) 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 레벨 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값. 최대 체벨 이진 트리 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리 왼쪽 자식 노드 (left child node) 오른쪽 자식 노드 (right child node) 레벨 i 에서의 노드의 최대 개수는 2^i 개 높이가 h 인 이진트리가 가질 수 있는 노드의 최소 개수는 h+1개, 최대 개수는 2^(h+1)-1개가 된다. 포화 이진 트리 (Full Binary Tree) 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리 높이가 h일 때, 최대의 노드 개수인 2^(h+1)-1의 노드를 가진 이진 트리 루트를 1번으로 하여 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐 완전 이진 트리 (Complete Binary Tree) 높이가 h 이고 노드 수가 n개 일 때, 포화 이진트리의 노드번호 1번부터 n 번까지 빈자리가 없는 이진트리 편향 이진 트리 (Skewed Binary Tree) 높이 h 에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리 왼쪽 편향 이진 트리 오른쪽 편향 이진 트리 순회 (traversal) 트리는 비 선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다. 따라서 특별한 방법이 필요하다. 트리의 각 노드를 중복되지 않게 전부 방문(visit)하는 것 3가지의 기본적인 순회방법 전위순회 (preorder traversal) : 루트-좌-우 중위순회 (inorder traversal) : 좌-루트-우 후위순회 (postorder traversal) : 좌-우-루트 전위순회 (preorder traversal)12345def preorder_traverse(T): if T: visit(T) preorder_traverse(T.left) preorder_traverse(T.right) 중위순회 (inorder traversal)12345def preorder_traverse(T): if T: preorder_traverse(T.left) visit(T) preorder_traverse(T.right) 후위순회 (postorder traversal)12345def preorder_traverse(T): if T: preorder_traverse(T.left) preorder_traverse(T.right) visit(T) 이진트리의 표현배열을 이용한 이진 트리의 표현 이진트리에 각 노드 번호를 다음과 같이 부여 루트의 번호를 1로 함 레벨 n 에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n 부터 2^(n+1)-1 까지 번호를 차례로 부여 노드번호의 성질 노드 번호가 i인 노드의 부모 노드 번호? i//2 노드 번호가 i인 노드의 왼쪽 자식 노드 번호? 2*i 노드 번호가 i인 노드의 오른쪽 자식 노드 번호? 2*i+1 레벨 n 의 노드 번호 시작 번호는? 2^n 이진트리 저장 및 순회 실습 코드1234567891011121314151617181920212223242526'''41 2 1 3 3 4 3 5'''def pre_order(v): if v: # 0번 정점이 없으므로... 0번은 자식이 없는 경우를 표시 print(v) # visit(v) pre_order(ch1[v]) pre_order(ch2[v])E = int(input()) # edge 수arr = list(map(int, input().split()))V = E + 1 # 정점 수 == 1번부터 V번까지 정점이 있을 때 마지막 정점# 부모 번호를 인덱스로 자식번호 저장ch1 = [0]*(V+1)ch2 = [0]*(V+1)for i in range(E): p, c = arr[i*2], arr[i*2+1] if ch1[p] == 0: ch1[p] = c else: ch2[p] = cprint(ch1)print(ch2)pre_order(1) 배열을 이용한 이진 트리의 표현의 단점 편향 이진 트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경 어려워 비효율적 연결리스트를 이용한 이진트리의 표현 이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현 이진탐색 트리힙","link":"/2022/03/16/tree/"},{"title":"sort","text":"빅-오 표기법 알고리즘의 작업량을 표현할 때 시간 복잡도를 이용한다. 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n 에 대한 항만을 표시 계수는 생략하여 표시 Bubble sort인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다. Counting sort항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘 Selection sort주어진 리스트중에 최소값을 찾아 그 값을 맨 앞에 위치한 값과 교체한다. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다. Quick sortpivot 을 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치 시킨다. 12345678910111213141516171819def quicksort(a, begin, end): if begin &lt; end: p = partition(a, begin, end) # 확정된 피봇 위치를 기준으로 quicksort(a, begin, p-1) # 왼쪽 구간에 대해 퀵 정렬을 다시 수행한다. quicksort(a, p+1, end) # 오른쪽 구간에 대해 퀵 정렬을 다시 수행한다. def partition(a, begin, end): pivot = (begin + end)//2 # 가운데 원소를 피봇으로 정한다. L = begin R = end while L &lt; R: while (L&lt;R and a[L] &lt; a[pivot]): L += 1 # 오른쪽으로 이동, 피봇보다 크거나 같은 원소 찾는다. while (L&lt;R and a[R] &gt;=a[pivot]): R -= 1 # 왼쪽으로 이동, 피봇보다 작은 원소 찾는다. if L &lt; R: if L == pivot : # L이 피봇이면 피봇 원소에 대한 자리교환이 발생 pivot = R # 교환한 자리를 피봇원소의 위치로 확정한다. a[L], a[R] = a[R], a[L] # L과 R의 원소를 바꾼다. a[pivot], a[R] = a[R], a[pivot] # L과 R이 만나면, 원소와 피봇을 교환하여 피봇위치를 확정한다. return R 알고리즘 기법 : 분할 정복 최악의 경우 O(N^2) 지만, 평균적으로는 가장 빠르다. O(nlogn) Insertion sortMerge sort","link":"/2022/02/22/sort/"}],"tags":[{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"터미널 명령어","slug":"터미널-명령어","link":"/tags/%ED%84%B0%EB%AF%B8%EB%84%90-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Brute Force","slug":"Brute-Force","link":"/tags/Brute-Force/"},{"name":"Rabin-Karp algorithm","slug":"Rabin-Karp-algorithm","link":"/tags/Rabin-Karp-algorithm/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"Boyer-Moore algorithm","slug":"Boyer-Moore-algorithm","link":"/tags/Boyer-Moore-algorithm/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"memoization","slug":"memoization","link":"/tags/memoization/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"계산기","slug":"계산기","link":"/tags/%EA%B3%84%EC%82%B0%EA%B8%B0/"},{"name":"백트래킹","slug":"백트래킹","link":"/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"엔디안","slug":"엔디안","link":"/tags/%EC%97%94%EB%94%94%EC%95%88/"},{"name":"선형큐","slug":"선형큐","link":"/tags/%EC%84%A0%ED%98%95%ED%81%90/"},{"name":"원형큐","slug":"원형큐","link":"/tags/%EC%9B%90%ED%98%95%ED%81%90/"},{"name":"우선순위큐","slug":"우선순위큐","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"빅-오 표기법","slug":"빅-오-표기법","link":"/tags/%EB%B9%85-%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"name":"Bubble sort","slug":"Bubble-sort","link":"/tags/Bubble-sort/"},{"name":"Counting sort","slug":"Counting-sort","link":"/tags/Counting-sort/"},{"name":"Selection sort","slug":"Selection-sort","link":"/tags/Selection-sort/"},{"name":"Quick sort","slug":"Quick-sort","link":"/tags/Quick-sort/"},{"name":"Insertion sort","slug":"Insertion-sort","link":"/tags/Insertion-sort/"},{"name":"Merge sort","slug":"Merge-sort","link":"/tags/Merge-sort/"}],"categories":[{"name":"startcamp","slug":"startcamp","link":"/categories/startcamp/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"Django","slug":"Django","link":"/categories/Django/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Computer Network","slug":"Computer-Network","link":"/categories/Computer-Network/"},{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"algo_python","slug":"algo-python","link":"/categories/algo-python/"},{"name":"python","slug":"python","link":"/categories/python/"}]}