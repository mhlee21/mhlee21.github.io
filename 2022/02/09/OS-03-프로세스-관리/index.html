<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Mihyun Lee">





<title>OS&gt;03.프로세스 관리 | Mihyun&#39;s Blog</title>



    <link rel="icon" href="/favicon_mhlee.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Mihyun&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Mihyun&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">OS&gt;03.프로세스 관리</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Mihyun Lee</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 9, 2022&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/OS/">OS</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="03-프로세스-관리"><a href="#03-프로세스-관리" class="headerlink" title="03. 프로세스 관리"></a>03. 프로세스 관리</h1><h2 id="프로그램의-실행"><a href="#프로그램의-실행" class="headerlink" title="프로그램의 실행"></a>프로그램의 실행</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220202220410618-16438070528791.png" alt="image-20220202220410618"></p>
<p>프로그램은 파일 형태로 파일 시스템에 저장되어있다. 프로그램이 실행되면 메모리에 올라가서 프로세스가 된다.</p>
<p>그 중간 단계가 virtual memory</p>
<p>프로그램이 실행될 때 각각의 프로그램은 독자적인 address space 가 있다.</p>
<p>필요한 부분만 물리적인 메모리에 올라가게되고 그렇지 않은 부분은 swap area 에 올라간다. </p>
<p>메모리 주소</p>
<ul>
<li>virtual memeory</li>
<li>physical memory</li>
</ul>
<p>이 두 메모리 주소 사이의 address translation 이 필요하다.</p>
<ul>
<li>address space (프로그램의 virtual memory)<ul>
<li>code : 실행 파일에 있는 기계어 code가 위치하는 부분 </li>
<li>data : 전역 변수</li>
<li>stack : 지역 변수, 함수 호출 시 사용되는 객체들</li>
</ul>
</li>
<li>kernel address space 도 code&#x2F;data&#x2F;stack 이 존재함</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220202234703590.png" alt="image-20220202234703590"></p>
<ul>
<li><p>운영체제 data 영역에는 모든 하드웨어&#x2F;프로세스를 관리하기 위한 자료구조를 가지고 있다.</p>
<ul>
<li>PCB(Process Control Block) : 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조</li>
</ul>
</li>
<li><p>운영체제 stack</p>
<ul>
<li>kernel 의 stack 은 각 프로세스마다 별도로 두고 있다.</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220203000244249.png" alt="image-20220203000244249"></p>
<ul>
<li>커널 함수<ul>
<li>프로그램 실행파일 안에 들어있는 것이 아니라 커널(kernel code) 안에 들어있음 (&#x3D;시스템 콜)</li>
<li>시스템콜 사용하기 위해 cpu 제어권을 프로세스에서 운영체제로 넘긴다.</li>
</ul>
</li>
</ul>
<p>CPU옆에는 mode bit이라는 것이 붙어있다.</p>
<p>mode bit 이 1 이면 user mode, 0이면 kernel mode</p>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220203000343581.png" alt="image-20220203000343581"></p>
<h2 id="프로세스의-개념"><a href="#프로세스의-개념" class="headerlink" title="프로세스의 개념"></a>프로세스의 개념</h2><ul>
<li>프로세스 : 실행중인 프로그램</li>
<li>프로세스의 문맥(context) : 프로세스의 현재 상태<ul>
<li>CPU 수행상태를 나타내는 하드웨어 문맥<ul>
<li>Program Counter</li>
<li>각종 register</li>
</ul>
</li>
<li>프로세스의 주소 공간<ul>
<li>code, data, stack</li>
</ul>
</li>
<li>프로세스 관련 커널 자료 구조<ul>
<li>PCB</li>
<li>Kernel stack</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204080940242.png" alt="image-20220204080940242"></p>
<h2 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204081504017.png" alt="image-20220204081504017"></p>
<ul>
<li><p>프로세스는 상태(state) 가 변경되며 수행된다.</p>
<ul>
<li>Running : CPU 에서 실행중인 프로세스<ul>
<li>CPU 를 잡고 instruction 을 수행중인 상태</li>
</ul>
</li>
<li>Ready : 실행 대기 상태에 있는 프로세스<ul>
<li>메모리 등 다른 조건을 만족하고 CPU 를 기다리는 상태</li>
</ul>
</li>
<li>Blocked : Disk I&#x2F;O 같은 오래 걸리는 작업때문에 당장 수행할 수 없는 상태<ul>
<li>CPU 를 주어도 당장 instruction 을 수행할 수 없는 상태</li>
<li>Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태</li>
</ul>
</li>
</ul>
<blockquote>
<p>New : 프로세스가 생성중인 상태</p>
<p>Terminated : 수행(execution) 이 끝난 상태</p>
</blockquote>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204082203559.png" alt="image-20220204082203559"></p>
<ul>
<li>운영체제(kernel)가 data 영역의 PCB로 프로세스의 상태를 관리한다.</li>
</ul>
<h2 id="프로세스의-상태도"><a href="#프로세스의-상태도" class="headerlink" title="프로세스의 상태도"></a>프로세스의 상태도</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204082242008.png" alt="image-20220204082242008"></p>
<ul>
<li>running 에서 상태 변하는 경우<ul>
<li>Timer interrupt</li>
<li>I&#x2F;O or event wait</li>
<li>exit</li>
</ul>
</li>
</ul>
<h2 id="Process-Control-Block-PCB"><a href="#Process-Control-Block-PCB" class="headerlink" title="Process Control Block(PCB)"></a>Process Control Block(PCB)</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204082546136.png" alt="image-20220204082546136"></p>
<ul>
<li>OS가 관리상 사용하는 정보<ul>
<li>Process state, PID, …</li>
</ul>
</li>
<li>CPU 수행 관련 하드웨어 값<ul>
<li>PC, registers</li>
</ul>
</li>
<li>메모리 관련<ul>
<li>code, data, stack 의 위치 정보</li>
</ul>
</li>
<li>파일 관련<ul>
<li>Open file descriptors</li>
</ul>
</li>
</ul>
<h2 id="Context-Switch-문맥-교환"><a href="#Context-Switch-문맥-교환" class="headerlink" title="Context Switch (문맥 교환)"></a>Context Switch (문맥 교환)</h2><ul>
<li>CPU 를 한 프로세스에서 다른 프로세스로 넘겨주는 과정</li>
<li>CPU 가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행<ul>
<li>CPU 를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장</li>
<li>CPU 를 새롭게 얻는 프로세스의 상태를 PCB 에서 읽어옴</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204082906201.png" alt="image-20220204082906201"></p>
<ul>
<li><p>❗ System call 이나 Interrupt 발생 시 반드시 context switch 가 일어나는 것은 아님</p>
<ul>
<li>(1) A가 실행되다가 다시 A가 실행 : 문맥교환이 아님</li>
<li>(2) A가 실행되다가 B 가 실행됨 : 문맥교환 발생</li>
</ul>
<blockquote>
<p>(1)의 경우에도 CPU 수행 정보 등 context 의 일부를 PCB 에 save 해야하지만, Context switch 가 발생한 (2) 의 경우 그 부담이 훨씬 큼</p>
</blockquote>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204083335468.png" alt="image-20220204083335468"></p>
<hr>
<p>➕참고</p>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204083941230.png" alt="image-20220204083941230"></p>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204084100908.png" alt="image-20220204084100908"></p>
<hr>
<h2 id="프로세스-스케줄링-큐의-모습"><a href="#프로세스-스케줄링-큐의-모습" class="headerlink" title="프로세스 스케줄링 큐의 모습"></a>프로세스 스케줄링 큐의 모습</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204084213391.png" alt="image-20220204084213391"></p>
<h2 id="스케줄러-Scheduler"><a href="#스케줄러-Scheduler" class="headerlink" title="스케줄러 (Scheduler)"></a>스케줄러 (Scheduler)</h2><ul>
<li>운영체제에서 스케줄링을 하는 코드를 스케줄러라고 한다. (&#x3D;코드의 일부)</li>
<li>Long-term scheduler<ul>
<li>프로세스 상태를 new에서 ready로 바꾸는 admitted 동작을 해준다.</li>
<li>우리가 다루는 일반적인 운영체제는 보통 장기 스케줄러가 없다.</li>
</ul>
</li>
<li>Medium-Term Scheduler<ul>
<li>장기 스케줄러가 없는 대신 사용하는 스케줄러</li>
<li>프로세스에게서 memory 를 뺏는다.</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204084422974.png" alt="image-20220204084422974"></p>
<h2 id="프로세스의-상태-1"><a href="#프로세스의-상태-1" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204095226065.png" alt="image-20220204095226065"></p>
<ul>
<li>Blocked 와 Suspended 모두 CPU 를 얻지 못한다.<ul>
<li>Blocked : 요청한 event 끝나면 다시 ready 상태로 돌아감</li>
<li>Suspended : 일을 아예 못하고 있는 상태, 외부에서 resume 시켜줘야 상태 변화 가능</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204095700365.png" alt="image-20220204095700365"></p>
<blockquote>
<p>usermode 와 kernel mode의 running 상태 확인하기</p>
<p>프로세스 상태 변화도 위의 그림 기준으로 공부할 것</p>
</blockquote>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li>Thread (&#x3D;lightweight process)<ul>
<li>프로세스의 CPU 수행 단위</li>
<li>CPU 수행 부분 (PC, register, Stack) 만 별도로 가지고 있고, 나머지는 공유</li>
</ul>
</li>
<li>Thread 가 동료 Thread와 공유하는 부분<ul>
<li>code</li>
<li>data</li>
<li>OS resources</li>
</ul>
</li>
<li>전통적인 개념의 heavyweight process 는 하나의 thread 를 가지고 있는 task 로 볼 수 있다.</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204190905351.png" alt="image-20220204190905351"></p>
<ul>
<li>single CPU 에서의 장점<ul>
<li><strong>Responsiveness</strong> : 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리를 할 수 있다.</li>
<li><strong>Resource Sharing</strong> : 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput) 과 성능향상을 얻을 수 있다.</li>
<li><strong>Economy</strong> : Context switch 보다 overhead 가 적다.</li>
</ul>
</li>
<li>multi CPU (multi processor) 에서의 장점<ul>
<li><strong>Utilization of Multi-Architectures</strong> : 스레드를 사용하면 병렬성을 높일 수 있다.</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204191816646.png" alt="image-20220204191816646"></p>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204191828153.png" alt="image-20220204191828153"></p>
<ul>
<li>thread 를 구현하는 방법에 따른 분류<ul>
<li>Kernel Threads<ul>
<li>운영체제가 thread 의 존재를 아는 경우</li>
<li>운영체제에서 thread 에게 직접 CPU 넘긴다.</li>
</ul>
</li>
<li>User Threads<ul>
<li>운영체제가 thread 의 존재를 모르는 경우</li>
<li>사용자 프로그램에서 thread 를 관리</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="프로세스-생성-Process-Creation"><a href="#프로세스-생성-Process-Creation" class="headerlink" title="프로세스 생성 (Process Creation)"></a>프로세스 생성 (Process Creation)</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204192948837.png" alt="image-20220204192948837"></p>
<ul>
<li><p>일반적으로 process 는 자원을 차지하기 위해 경쟁한다.</p>
</li>
<li><p>주소 공간 (Address space)</p>
<ul>
<li><p>자식은 부모의 공간을 복사함 (binary and OS data)</p>
</li>
<li><p>자식은 그 공간에 새로운 프로그램을 올림</p>
</li>
<li><p><em><strong>fork()</strong></em> 시스템 콜이 새로운 프로세스를 생성</p>
<ul>
<li><p>부모를 그대로 복사</p>
</li>
<li><p>주소 공간 할당</p>
</li>
<li><p>fork() 다음에 이어지는 <em><strong>exec()</strong></em> 시스템 콜을 통해 새로운 프로그램을 메모리에 올림</p>
<blockquote>
<p>fork 와 exec 의 차이점?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="프로세스-종료-Process-Termination"><a href="#프로세스-종료-Process-Termination" class="headerlink" title="프로세스 종료 (Process Termination)"></a>프로세스 종료 (Process Termination)</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204195211276.png" alt="image-20220204195211276"></p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204195709062.png" alt="image-20220204195709062"></p>
<ul>
<li>부모 프로세스는  fork() 다음 코드를 실행하고, 복제된 자식프로세스는 부모와 똑같이 fork() 다음부터 실행한다. (Program counter 도 복제하기 때문)</li>
<li>fork() 는 프로세스의 pid를 리턴한다.<ul>
<li>pid &#x3D;&#x3D; 0 이면 자식프로세스</li>
<li>pid &gt; 0 이면 부모 프로세스</li>
</ul>
</li>
</ul>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204200317873.png" alt="image-20220204200317873"></p>
<ul>
<li>Hello 를 출력하고 data 프로그램이 덮어 씌워진다.</li>
<li>execpl 이후 코드는 실행되지 않는다.</li>
</ul>
<p><img src="/2022/02/09/OS-03-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/image-20220204200222921.png" alt="image-20220204200222921"></p>
<ul>
<li>부모 프로세스는 기존 코드 실행하고, 자식프로세스는 execpl 통해 date 프로그램 덮어 씌워진다.</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Mihyun Lee</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/OS/"># OS</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/02/12/OS-04-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/">OS>04.CPU 스케줄링</a>
            
            
            <a class="next" rel="next" href="/2022/02/07/WEB-%EA%B7%B8%EB%A6%AC%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9/">WEB>그리드 시스템/반응형 웹</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Mihyun Lee | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>